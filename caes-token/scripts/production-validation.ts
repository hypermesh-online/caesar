import { ethers } from "hardhat";
import fs from "fs";
import path from "path";

interface DeploymentInfo {
  network: string;
  chainId: number;
  contracts: {
    Caesar?: string;
    FinalCAES?: string;
    [key: string]: any;
  };
  tokenDetails?: {
    name: string;
    symbol: string;
    totalSupply: string;
  };
}

interface TestResults {
  contractValidation: boolean;
  tokenMetadata: any;
  ownershipVerification: boolean;
  demurrageSystemActive: boolean;
  antiSpeculationActive: boolean;
  crossChainReady: boolean;
  economicMetrics: any;
  scalabilityMetrics: any;
}

async function main() {
  console.log("üîç Starting Production Validation on Sepolia Testnet\n");
  
  const network = await ethers.provider.getNetwork();
  console.log(`Network: ${network.name} (Chain ID: ${network.chainId})`);
  
  // Load deployment information
  const deploymentFiles = [
    "deployments/sepolia.json",
    "deployments/final-caes-sepolia.json"
  ];
  
  let deploymentInfo: DeploymentInfo | null = null;
  let caesarAddress: string | null = null;
  
  for (const file of deploymentFiles) {
    if (fs.existsSync(file)) {
      const deployment = JSON.parse(fs.readFileSync(file, 'utf8')) as DeploymentInfo;
      console.log(`üìã Found deployment: ${file}`);
      
      if (deployment.contracts.Caesar) {
        caesarAddress = deployment.contracts.Caesar;
        deploymentInfo = deployment;
        break;
      } else if (deployment.contracts.FinalCAES) {
        caesarAddress = deployment.contracts.FinalCAES;
        deploymentInfo = deployment;
        break;
      }
    }
  }
  
  if (!caesarAddress || !deploymentInfo) {
    console.error("‚ùå No valid Caesar token deployment found!");
    process.exit(1);
  }
  
  console.log(`‚úÖ Using Caesar token at: ${caesarAddress}\n`);
  
  // Initialize test results
  const results: TestResults = {
    contractValidation: false,
    tokenMetadata: {},
    ownershipVerification: false,
    demurrageSystemActive: false,
    antiSpeculationActive: false,
    crossChainReady: false,
    economicMetrics: {},
    scalabilityMetrics: {}
  };
  
  try {
    // Connect to the deployed contract
    const Caesar = await ethers.getContractFactory("CaesarToken");
    const caesar = Caesar.attach(caesarAddress);
    
    console.log("1Ô∏è‚É£ Contract Validation");
    console.log("========================");
    
    // Basic contract validation
    try {
      const name = await caesar.name();
      const symbol = await caesar.symbol();
      const decimals = await caesar.decimals();
      const totalSupply = await caesar.totalSupply();
      
      results.tokenMetadata = {
        name,
        symbol,
        decimals: Number(decimals),
        totalSupply: ethers.formatEther(totalSupply)
      };
      
      console.log(`‚úÖ Token Name: ${name}`);
      console.log(`‚úÖ Token Symbol: ${symbol}`);
      console.log(`‚úÖ Decimals: ${decimals}`);
      console.log(`‚úÖ Total Supply: ${ethers.formatEther(totalSupply)} CAES`);
      
      results.contractValidation = true;
    } catch (error) {
      console.log(`‚ùå Contract validation failed: ${error}`);
    }
    
    console.log("\n2Ô∏è‚É£ Ownership and Access Control");
    console.log("=================================");
    
    try {
      const owner = await caesar.owner();
      const [deployer] = await ethers.getSigners();
      
      console.log(`‚úÖ Contract Owner: ${owner}`);
      console.log(`‚úÖ Deployer Address: ${deployer.address}`);
      
      results.ownershipVerification = owner.toLowerCase() === deployer.address.toLowerCase();
      console.log(`${results.ownershipVerification ? '‚úÖ' : '‚ùå'} Ownership verification: ${results.ownershipVerification}`);
    } catch (error) {
      console.log(`‚ùå Ownership verification failed: ${error}`);
    }
    
    console.log("\n3Ô∏è‚É£ Economic System Validation");
    console.log("===============================");
    
    try {
      // Check demurrage system
      const demurrageManagerAddress = await caesar.demurrageManager();
      const antiSpeculationEngineAddress = await caesar.antiSpeculationEngine();
      
      console.log(`‚úÖ Demurrage Manager: ${demurrageManagerAddress}`);
      console.log(`‚úÖ Anti-Speculation Engine: ${antiSpeculationEngineAddress}`);
      
      results.demurrageSystemActive = demurrageManagerAddress !== ethers.ZeroAddress;
      results.antiSpeculationActive = antiSpeculationEngineAddress !== ethers.ZeroAddress;
      
      // Test economic metrics
      const currentEpoch = await caesar.getCurrentEpoch();
      const epochDuration = await caesar.getEpochDuration();
      const networkHealthIndex = await caesar.getNetworkHealthIndex();
      const stabilityPoolBalance = await caesar.getStabilityPoolBalance();
      
      results.economicMetrics = {
        currentEpoch: Number(currentEpoch),
        epochDuration: Number(epochDuration),
        networkHealthIndex: Number(networkHealthIndex),
        stabilityPoolBalance: ethers.formatEther(stabilityPoolBalance)
      };
      
      console.log(`‚úÖ Current Epoch: ${currentEpoch}`);
      console.log(`‚úÖ Epoch Duration: ${epochDuration} seconds`);
      console.log(`‚úÖ Network Health Index: ${networkHealthIndex}`);
      console.log(`‚úÖ Stability Pool Balance: ${ethers.formatEther(stabilityPoolBalance)} CAES`);
      
    } catch (error) {
      console.log(`‚ùå Economic system validation failed: ${error}`);
    }
    
    console.log("\n4Ô∏è‚É£ Cross-Chain Capabilities");
    console.log("=============================");
    
    try {
      // Check LayerZero integration
      const hasLayerZero = typeof caesar.bridgeWithDecay === 'function';
      results.crossChainReady = hasLayerZero;
      
      console.log(`${hasLayerZero ? '‚úÖ' : '‚ùå'} LayerZero Bridge Functions: ${hasLayerZero}`);
      
      if (hasLayerZero) {
        console.log(`‚úÖ Bridge with Decay: Available`);
        console.log(`‚úÖ Quote Bridge with Decay: Available`);
      }
    } catch (error) {
      console.log(`‚ùå Cross-chain validation failed: ${error}`);
    }
    
    console.log("\n5Ô∏è‚É£ Transaction Testing");
    console.log("========================");
    
    try {
      const [deployer] = await ethers.getSigners();
      const balance = await caesar.balanceOf(deployer.address);
      
      console.log(`‚úÖ Owner Balance: ${ethers.formatEther(balance)} CAES`);
      
      // Test if migration is enabled to mint some tokens for testing
      try {
        await caesar.setMigrationContract(deployer.address);
        await caesar.setMigrationEnabled(true);
        
        if (balance === 0n) {
          console.log(`üîÑ Minting test tokens...`);
          const mintAmount = ethers.parseEther("10000");
          const tx = await caesar.migrationMint(deployer.address, mintAmount);
          await tx.wait();
          
          const newBalance = await caesar.balanceOf(deployer.address);
          console.log(`‚úÖ Minted: ${ethers.formatEther(newBalance)} CAES`);
        }
        
        // Test basic transfer functionality
        const transferAmount = ethers.parseEther("100");
        const balanceBefore = await caesar.balanceOf(deployer.address);
        
        if (balanceBefore >= transferAmount) {
          console.log(`üîÑ Testing transfer functionality...`);
          const tx = await caesar.transfer(deployer.address, transferAmount);
          const receipt = await tx.wait();
          
          console.log(`‚úÖ Transfer successful - Gas used: ${receipt?.gasUsed || 'N/A'}`);
          
          results.scalabilityMetrics = {
            transferGasUsed: Number(receipt?.gasUsed || 0),
            transferSuccessful: true
          };
        }
        
      } catch (error) {
        console.log(`‚ö†Ô∏è  Transaction testing limited: ${error}`);
      }
      
    } catch (error) {
      console.log(`‚ùå Transaction testing failed: ${error}`);
    }
    
    console.log("\n6Ô∏è‚É£ Performance Analysis");
    console.log("=========================");
    
    try {
      // Get recent block information
      const currentBlock = await ethers.provider.getBlockNumber();
      const blockInfo = await ethers.provider.getBlock(currentBlock);
      
      console.log(`‚úÖ Current Block: ${currentBlock}`);
      console.log(`‚úÖ Block Timestamp: ${new Date(blockInfo!.timestamp * 1000).toISOString()}`);
      console.log(`‚úÖ Gas Limit: ${blockInfo!.gasLimit}`);
      
      // Estimate gas for various operations
      const [deployer] = await ethers.getSigners();
      
      try {
        const transferGasEstimate = await caesar.transfer.estimateGas(deployer.address, ethers.parseEther("1"));
        console.log(`‚úÖ Transfer Gas Estimate: ${transferGasEstimate}`);
        
        const demurrageGasEstimate = await caesar.calculateDemurrage.estimateGas(deployer.address);
        console.log(`‚úÖ Demurrage Calculation Gas Estimate: ${demurrageGasEstimate}`);
        
        results.scalabilityMetrics = {
          ...results.scalabilityMetrics,
          transferGasEstimate: Number(transferGasEstimate),
          demurrageGasEstimate: Number(demurrageGasEstimate)
        };
        
      } catch (gasError) {
        console.log(`‚ö†Ô∏è  Gas estimation limited: ${gasError}`);
      }
      
    } catch (error) {
      console.log(`‚ùå Performance analysis failed: ${error}`);
    }
    
  } catch (error) {
    console.error(`‚ùå Critical error during validation: ${error}`);
  }
  
  // Generate comprehensive report
  console.log("\n" + "=".repeat(80));
  console.log("üìä PRODUCTION VALIDATION REPORT");
  console.log("=".repeat(80));
  
  console.log(`\nüèõÔ∏è Contract Status:`);
  console.log(`‚úÖ Deployed Address: ${caesarAddress}`);
  console.log(`${results.contractValidation ? '‚úÖ' : '‚ùå'} Basic Validation: ${results.contractValidation ? 'PASSED' : 'FAILED'}`);
  console.log(`${results.ownershipVerification ? '‚úÖ' : '‚ùå'} Ownership Control: ${results.ownershipVerification ? 'VERIFIED' : 'FAILED'}`);
  
  console.log(`\nüè¶ Economic Systems:`);
  console.log(`${results.demurrageSystemActive ? '‚úÖ' : '‚ùå'} Demurrage System: ${results.demurrageSystemActive ? 'ACTIVE' : 'INACTIVE'}`);
  console.log(`${results.antiSpeculationActive ? '‚úÖ' : '‚ùå'} Anti-Speculation: ${results.antiSpeculationActive ? 'ACTIVE' : 'INACTIVE'}`);
  
  console.log(`\nüåê Cross-Chain Capabilities:`);
  console.log(`${results.crossChainReady ? '‚úÖ' : '‚ùå'} LayerZero Integration: ${results.crossChainReady ? 'READY' : 'NOT READY'}`);
  
  console.log(`\n‚ö° Performance Metrics:`);
  if (results.scalabilityMetrics.transferGasEstimate) {
    const gasPrice = 20; // gwei
    const ethPrice = 2500; // USD
    const transferCostUSD = (results.scalabilityMetrics.transferGasEstimate * gasPrice * ethPrice) / 1e9 / 1e18;
    console.log(`‚úÖ Transfer Gas: ${results.scalabilityMetrics.transferGasEstimate} (~$${transferCostUSD.toFixed(4)})`);
  }
  if (results.scalabilityMetrics.demurrageGasEstimate) {
    console.log(`‚úÖ Demurrage Gas: ${results.scalabilityMetrics.demurrageGasEstimate}`);
  }
  
  // Overall readiness assessment
  const systemsActive = results.demurrageSystemActive && results.antiSpeculationActive;
  const basicValidation = results.contractValidation && results.ownershipVerification;
  const overallReadiness = systemsActive && basicValidation;
  
  console.log(`\nüéØ OVERALL READINESS:`);
  console.log(`${overallReadiness ? 'üü¢' : 'üü°'} Production Status: ${overallReadiness ? 'READY FOR TESTING' : 'NEEDS ATTENTION'}`);
  
  if (overallReadiness) {
    console.log(`\nüöÄ NEXT STEPS:`);
    console.log(`1. Begin user acceptance testing`);
    console.log(`2. Configure cross-chain parameters`);
    console.log(`3. Set up monitoring and alerts`);
    console.log(`4. Prepare mainnet deployment`);
  } else {
    console.log(`\n‚ö†Ô∏è  ISSUES TO RESOLVE:`);
    if (!results.contractValidation) console.log(`‚ùå Fix contract validation issues`);
    if (!results.ownershipVerification) console.log(`‚ùå Verify ownership configuration`);
    if (!results.demurrageSystemActive) console.log(`‚ùå Activate demurrage system`);
    if (!results.antiSpeculationActive) console.log(`‚ùå Activate anti-speculation engine`);
  }
  
  // Save report
  const reportData = {
    timestamp: new Date().toISOString(),
    network: network.name,
    chainId: network.chainId,
    contractAddress: caesarAddress,
    results,
    overallReadiness
  };
  
  const reportPath = `test-reports/production-validation-${Date.now()}.json`;
  fs.mkdirSync(path.dirname(reportPath), { recursive: true });
  fs.writeFileSync(reportPath, JSON.stringify(reportData, null, 2));
  
  console.log(`\nüìù Report saved: ${reportPath}`);
  
  process.exit(overallReadiness ? 0 : 1);
}

if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}