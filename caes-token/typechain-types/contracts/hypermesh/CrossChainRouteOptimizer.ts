/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../../common";

export declare namespace CrossChainRouteOptimizer {
  export type RoutePathStruct = {
    networks: string[];
    expectedCosts: BigNumberish[];
    expectedLatencies: BigNumberish[];
    totalCost: BigNumberish;
    totalLatency: BigNumberish;
    qualityScore: BigNumberish;
    reliabilityScore: BigNumberish;
    isActive: boolean;
  };

  export type RoutePathStructOutput = [
    string[],
    BigNumber[],
    BigNumber[],
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    networks: string[];
    expectedCosts: BigNumber[];
    expectedLatencies: BigNumber[];
    totalCost: BigNumber;
    totalLatency: BigNumber;
    qualityScore: BigNumber;
    reliabilityScore: BigNumber;
    isActive: boolean;
  };

  export type NetworkMetricsStruct = {
    successRate: BigNumberish;
    averageLatency: BigNumberish;
    currentLoad: BigNumberish;
    capacityUtilization: BigNumberish;
    lastFailureTime: BigNumberish;
    consecutiveFailures: BigNumberish;
    totalTransactions: BigNumberish;
    lastUpdate: BigNumberish;
  };

  export type NetworkMetricsStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    successRate: BigNumber;
    averageLatency: BigNumber;
    currentLoad: BigNumber;
    capacityUtilization: BigNumber;
    lastFailureTime: BigNumber;
    consecutiveFailures: BigNumber;
    totalTransactions: BigNumber;
    lastUpdate: BigNumber;
  };

  export type RouteRequestStruct = {
    requestId: BytesLike;
    sender: string;
    targetNetwork: string;
    amount: BigNumberish;
    maxCost: BigNumberish;
    maxLatency: BigNumberish;
    priority: BigNumberish;
    timestamp: BigNumberish;
    status: BigNumberish;
  };

  export type RouteRequestStructOutput = [
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number
  ] & {
    requestId: string;
    sender: string;
    targetNetwork: string;
    amount: BigNumber;
    maxCost: BigNumber;
    maxLatency: BigNumber;
    priority: BigNumber;
    timestamp: BigNumber;
    status: number;
  };

  export type RouteConfigStruct = {
    maxRetries: BigNumberish;
    timeoutWindow: BigNumberish;
    costThresholdPercent: BigNumberish;
    latencyThresholdMs: BigNumberish;
    minQualityScore: BigNumberish;
    emergencyRerouteThreshold: BigNumberish;
    adaptiveRoutingEnabled: boolean;
  };

  export type RouteConfigStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    maxRetries: BigNumber;
    timeoutWindow: BigNumber;
    costThresholdPercent: BigNumber;
    latencyThresholdMs: BigNumber;
    minQualityScore: BigNumber;
    emergencyRerouteThreshold: BigNumber;
    adaptiveRoutingEnabled: boolean;
  };
}

export interface CrossChainRouteOptimizerInterface extends utils.Interface {
  functions: {
    "activeNetworks(uint256)": FunctionFragment;
    "addSupportedNetwork(address)": FunctionFragment;
    "calculatedRoutes(bytes32)": FunctionFragment;
    "currentThrottleMode()": FunctionFragment;
    "economicsOracle()": FunctionFragment;
    "emergencyPauseNetwork(address,string)": FunctionFragment;
    "executeRoute(bytes32)": FunctionFragment;
    "failedRoutes()": FunctionFragment;
    "getCalculatedRoute(bytes32)": FunctionFragment;
    "getNetworkMetrics(address)": FunctionFragment;
    "getRouteRequest(bytes32)": FunctionFragment;
    "getSystemStats()": FunctionFragment;
    "lastThrottleUpdate()": FunctionFragment;
    "networkMetrics(address)": FunctionFragment;
    "owner()": FunctionFragment;
    "paused()": FunctionFragment;
    "pendingRequests(uint256)": FunctionFragment;
    "rateLimits(address)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "requestRoute(address,uint256,uint256,uint256,uint256)": FunctionFragment;
    "reroutedTransactions()": FunctionFragment;
    "routeConfig()": FunctionFragment;
    "routeRequests(bytes32)": FunctionFragment;
    "setThrottleMode(uint8,string)": FunctionFragment;
    "successfulRoutes()": FunctionFragment;
    "supportedNetworks(address)": FunctionFragment;
    "totalRequests()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "updateRouteConfig((uint256,uint256,uint256,uint256,uint256,uint256,bool))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "activeNetworks"
      | "addSupportedNetwork"
      | "calculatedRoutes"
      | "currentThrottleMode"
      | "economicsOracle"
      | "emergencyPauseNetwork"
      | "executeRoute"
      | "failedRoutes"
      | "getCalculatedRoute"
      | "getNetworkMetrics"
      | "getRouteRequest"
      | "getSystemStats"
      | "lastThrottleUpdate"
      | "networkMetrics"
      | "owner"
      | "paused"
      | "pendingRequests"
      | "rateLimits"
      | "renounceOwnership"
      | "requestRoute"
      | "reroutedTransactions"
      | "routeConfig"
      | "routeRequests"
      | "setThrottleMode"
      | "successfulRoutes"
      | "supportedNetworks"
      | "totalRequests"
      | "transferOwnership"
      | "updateRouteConfig"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "activeNetworks",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addSupportedNetwork",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "calculatedRoutes",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "currentThrottleMode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "economicsOracle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyPauseNetwork",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "executeRoute",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "failedRoutes",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCalculatedRoute",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getNetworkMetrics",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getRouteRequest",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getSystemStats",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastThrottleUpdate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "networkMetrics",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingRequests",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "rateLimits", values: [string]): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "requestRoute",
    values: [string, BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "reroutedTransactions",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "routeConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "routeRequests",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setThrottleMode",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "successfulRoutes",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "supportedNetworks",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "totalRequests",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateRouteConfig",
    values: [CrossChainRouteOptimizer.RouteConfigStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "activeNetworks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSupportedNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculatedRoutes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentThrottleMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "economicsOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyPauseNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeRoute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "failedRoutes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCalculatedRoute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNetworkMetrics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRouteRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSystemStats",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastThrottleUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "networkMetrics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingRequests",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rateLimits", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestRoute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reroutedTransactions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "routeConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "routeRequests",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setThrottleMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "successfulRoutes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportedNetworks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalRequests",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateRouteConfig",
    data: BytesLike
  ): Result;

  events: {
    "EmergencyRerouteActivated(address,string)": EventFragment;
    "NetworkMetricsUpdated(address,uint256,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Paused(address)": EventFragment;
    "RateLimitTriggered(address,uint256,uint256)": EventFragment;
    "RouteCalculated(bytes32,address[],uint256,uint256)": EventFragment;
    "RouteExecuted(bytes32,bool,uint256,uint256)": EventFragment;
    "RouteRequested(bytes32,address,address,uint256)": EventFragment;
    "RouteRerouted(bytes32,address,address,string)": EventFragment;
    "ThrottleModeChanged(uint8,uint8,string)": EventFragment;
    "Unpaused(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "EmergencyRerouteActivated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NetworkMetricsUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RateLimitTriggered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouteCalculated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouteExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouteRequested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouteRerouted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ThrottleModeChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}

export interface EmergencyRerouteActivatedEventObject {
  network: string;
  reason: string;
}
export type EmergencyRerouteActivatedEvent = TypedEvent<
  [string, string],
  EmergencyRerouteActivatedEventObject
>;

export type EmergencyRerouteActivatedEventFilter =
  TypedEventFilter<EmergencyRerouteActivatedEvent>;

export interface NetworkMetricsUpdatedEventObject {
  network: string;
  successRate: BigNumber;
  averageLatency: BigNumber;
}
export type NetworkMetricsUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  NetworkMetricsUpdatedEventObject
>;

export type NetworkMetricsUpdatedEventFilter =
  TypedEventFilter<NetworkMetricsUpdatedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RateLimitTriggeredEventObject {
  network: string;
  currentLoad: BigNumber;
  backoffDuration: BigNumber;
}
export type RateLimitTriggeredEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  RateLimitTriggeredEventObject
>;

export type RateLimitTriggeredEventFilter =
  TypedEventFilter<RateLimitTriggeredEvent>;

export interface RouteCalculatedEventObject {
  requestId: string;
  networks: string[];
  totalCost: BigNumber;
  totalLatency: BigNumber;
}
export type RouteCalculatedEvent = TypedEvent<
  [string, string[], BigNumber, BigNumber],
  RouteCalculatedEventObject
>;

export type RouteCalculatedEventFilter = TypedEventFilter<RouteCalculatedEvent>;

export interface RouteExecutedEventObject {
  requestId: string;
  success: boolean;
  actualCost: BigNumber;
  actualLatency: BigNumber;
}
export type RouteExecutedEvent = TypedEvent<
  [string, boolean, BigNumber, BigNumber],
  RouteExecutedEventObject
>;

export type RouteExecutedEventFilter = TypedEventFilter<RouteExecutedEvent>;

export interface RouteRequestedEventObject {
  requestId: string;
  sender: string;
  targetNetwork: string;
  amount: BigNumber;
}
export type RouteRequestedEvent = TypedEvent<
  [string, string, string, BigNumber],
  RouteRequestedEventObject
>;

export type RouteRequestedEventFilter = TypedEventFilter<RouteRequestedEvent>;

export interface RouteReroutedEventObject {
  requestId: string;
  fromNetwork: string;
  toNetwork: string;
  reason: string;
}
export type RouteReroutedEvent = TypedEvent<
  [string, string, string, string],
  RouteReroutedEventObject
>;

export type RouteReroutedEventFilter = TypedEventFilter<RouteReroutedEvent>;

export interface ThrottleModeChangedEventObject {
  oldMode: number;
  newMode: number;
  reason: string;
}
export type ThrottleModeChangedEvent = TypedEvent<
  [number, number, string],
  ThrottleModeChangedEventObject
>;

export type ThrottleModeChangedEventFilter =
  TypedEventFilter<ThrottleModeChangedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface CrossChainRouteOptimizer extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CrossChainRouteOptimizerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    activeNetworks(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    addSupportedNetwork(
      network: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    calculatedRoutes(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
        totalCost: BigNumber;
        totalLatency: BigNumber;
        qualityScore: BigNumber;
        reliabilityScore: BigNumber;
        isActive: boolean;
      }
    >;

    currentThrottleMode(overrides?: CallOverrides): Promise<[number]>;

    economicsOracle(overrides?: CallOverrides): Promise<[string]>;

    emergencyPauseNetwork(
      network: string,
      reason: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    executeRoute(
      requestId: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    failedRoutes(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCalculatedRoute(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[CrossChainRouteOptimizer.RoutePathStructOutput]>;

    getNetworkMetrics(
      network: string,
      overrides?: CallOverrides
    ): Promise<[CrossChainRouteOptimizer.NetworkMetricsStructOutput]>;

    getRouteRequest(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[CrossChainRouteOptimizer.RouteRequestStructOutput]>;

    getSystemStats(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, number] & {
        totalRequestCount: BigNumber;
        successfulRouteCount: BigNumber;
        failedRouteCount: BigNumber;
        rerouteCount: BigNumber;
        activeNetworkCount: BigNumber;
        throttleMode: number;
      }
    >;

    lastThrottleUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    networkMetrics(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        successRate: BigNumber;
        averageLatency: BigNumber;
        currentLoad: BigNumber;
        capacityUtilization: BigNumber;
        lastFailureTime: BigNumber;
        consecutiveFailures: BigNumber;
        totalTransactions: BigNumber;
        lastUpdate: BigNumber;
      }
    >;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    pendingRequests(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    rateLimits(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
        currentCount: BigNumber;
        maxCount: BigNumber;
        windowStart: BigNumber;
        windowDuration: BigNumber;
        backoffUntil: BigNumber;
        isThrottled: boolean;
      }
    >;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    requestRoute(
      targetNetwork: string,
      amount: BigNumberish,
      maxCost: BigNumberish,
      maxLatency: BigNumberish,
      priority: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    reroutedTransactions(overrides?: CallOverrides): Promise<[BigNumber]>;

    routeConfig(
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean
      ] & {
        maxRetries: BigNumber;
        timeoutWindow: BigNumber;
        costThresholdPercent: BigNumber;
        latencyThresholdMs: BigNumber;
        minQualityScore: BigNumber;
        emergencyRerouteThreshold: BigNumber;
        adaptiveRoutingEnabled: boolean;
      }
    >;

    routeRequests(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number
      ] & {
        requestId: string;
        sender: string;
        targetNetwork: string;
        amount: BigNumber;
        maxCost: BigNumber;
        maxLatency: BigNumber;
        priority: BigNumber;
        timestamp: BigNumber;
        status: number;
      }
    >;

    setThrottleMode(
      mode: BigNumberish,
      reason: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    successfulRoutes(overrides?: CallOverrides): Promise<[BigNumber]>;

    supportedNetworks(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    totalRequests(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateRouteConfig(
      newConfig: CrossChainRouteOptimizer.RouteConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  activeNetworks(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  addSupportedNetwork(
    network: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  calculatedRoutes(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
      totalCost: BigNumber;
      totalLatency: BigNumber;
      qualityScore: BigNumber;
      reliabilityScore: BigNumber;
      isActive: boolean;
    }
  >;

  currentThrottleMode(overrides?: CallOverrides): Promise<number>;

  economicsOracle(overrides?: CallOverrides): Promise<string>;

  emergencyPauseNetwork(
    network: string,
    reason: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  executeRoute(
    requestId: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  failedRoutes(overrides?: CallOverrides): Promise<BigNumber>;

  getCalculatedRoute(
    requestId: BytesLike,
    overrides?: CallOverrides
  ): Promise<CrossChainRouteOptimizer.RoutePathStructOutput>;

  getNetworkMetrics(
    network: string,
    overrides?: CallOverrides
  ): Promise<CrossChainRouteOptimizer.NetworkMetricsStructOutput>;

  getRouteRequest(
    requestId: BytesLike,
    overrides?: CallOverrides
  ): Promise<CrossChainRouteOptimizer.RouteRequestStructOutput>;

  getSystemStats(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, number] & {
      totalRequestCount: BigNumber;
      successfulRouteCount: BigNumber;
      failedRouteCount: BigNumber;
      rerouteCount: BigNumber;
      activeNetworkCount: BigNumber;
      throttleMode: number;
    }
  >;

  lastThrottleUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  networkMetrics(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      successRate: BigNumber;
      averageLatency: BigNumber;
      currentLoad: BigNumber;
      capacityUtilization: BigNumber;
      lastFailureTime: BigNumber;
      consecutiveFailures: BigNumber;
      totalTransactions: BigNumber;
      lastUpdate: BigNumber;
    }
  >;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  pendingRequests(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  rateLimits(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
      currentCount: BigNumber;
      maxCount: BigNumber;
      windowStart: BigNumber;
      windowDuration: BigNumber;
      backoffUntil: BigNumber;
      isThrottled: boolean;
    }
  >;

  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  requestRoute(
    targetNetwork: string,
    amount: BigNumberish,
    maxCost: BigNumberish,
    maxLatency: BigNumberish,
    priority: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  reroutedTransactions(overrides?: CallOverrides): Promise<BigNumber>;

  routeConfig(
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      boolean
    ] & {
      maxRetries: BigNumber;
      timeoutWindow: BigNumber;
      costThresholdPercent: BigNumber;
      latencyThresholdMs: BigNumber;
      minQualityScore: BigNumber;
      emergencyRerouteThreshold: BigNumber;
      adaptiveRoutingEnabled: boolean;
    }
  >;

  routeRequests(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number
    ] & {
      requestId: string;
      sender: string;
      targetNetwork: string;
      amount: BigNumber;
      maxCost: BigNumber;
      maxLatency: BigNumber;
      priority: BigNumber;
      timestamp: BigNumber;
      status: number;
    }
  >;

  setThrottleMode(
    mode: BigNumberish,
    reason: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  successfulRoutes(overrides?: CallOverrides): Promise<BigNumber>;

  supportedNetworks(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  totalRequests(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateRouteConfig(
    newConfig: CrossChainRouteOptimizer.RouteConfigStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    activeNetworks(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    addSupportedNetwork(
      network: string,
      overrides?: CallOverrides
    ): Promise<void>;

    calculatedRoutes(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
        totalCost: BigNumber;
        totalLatency: BigNumber;
        qualityScore: BigNumber;
        reliabilityScore: BigNumber;
        isActive: boolean;
      }
    >;

    currentThrottleMode(overrides?: CallOverrides): Promise<number>;

    economicsOracle(overrides?: CallOverrides): Promise<string>;

    emergencyPauseNetwork(
      network: string,
      reason: string,
      overrides?: CallOverrides
    ): Promise<void>;

    executeRoute(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    failedRoutes(overrides?: CallOverrides): Promise<BigNumber>;

    getCalculatedRoute(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<CrossChainRouteOptimizer.RoutePathStructOutput>;

    getNetworkMetrics(
      network: string,
      overrides?: CallOverrides
    ): Promise<CrossChainRouteOptimizer.NetworkMetricsStructOutput>;

    getRouteRequest(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<CrossChainRouteOptimizer.RouteRequestStructOutput>;

    getSystemStats(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, number] & {
        totalRequestCount: BigNumber;
        successfulRouteCount: BigNumber;
        failedRouteCount: BigNumber;
        rerouteCount: BigNumber;
        activeNetworkCount: BigNumber;
        throttleMode: number;
      }
    >;

    lastThrottleUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    networkMetrics(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        successRate: BigNumber;
        averageLatency: BigNumber;
        currentLoad: BigNumber;
        capacityUtilization: BigNumber;
        lastFailureTime: BigNumber;
        consecutiveFailures: BigNumber;
        totalTransactions: BigNumber;
        lastUpdate: BigNumber;
      }
    >;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    pendingRequests(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    rateLimits(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
        currentCount: BigNumber;
        maxCount: BigNumber;
        windowStart: BigNumber;
        windowDuration: BigNumber;
        backoffUntil: BigNumber;
        isThrottled: boolean;
      }
    >;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    requestRoute(
      targetNetwork: string,
      amount: BigNumberish,
      maxCost: BigNumberish,
      maxLatency: BigNumberish,
      priority: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    reroutedTransactions(overrides?: CallOverrides): Promise<BigNumber>;

    routeConfig(
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean
      ] & {
        maxRetries: BigNumber;
        timeoutWindow: BigNumber;
        costThresholdPercent: BigNumber;
        latencyThresholdMs: BigNumber;
        minQualityScore: BigNumber;
        emergencyRerouteThreshold: BigNumber;
        adaptiveRoutingEnabled: boolean;
      }
    >;

    routeRequests(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number
      ] & {
        requestId: string;
        sender: string;
        targetNetwork: string;
        amount: BigNumber;
        maxCost: BigNumber;
        maxLatency: BigNumber;
        priority: BigNumber;
        timestamp: BigNumber;
        status: number;
      }
    >;

    setThrottleMode(
      mode: BigNumberish,
      reason: string,
      overrides?: CallOverrides
    ): Promise<void>;

    successfulRoutes(overrides?: CallOverrides): Promise<BigNumber>;

    supportedNetworks(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    totalRequests(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    updateRouteConfig(
      newConfig: CrossChainRouteOptimizer.RouteConfigStruct,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "EmergencyRerouteActivated(address,string)"(
      network?: string | null,
      reason?: null
    ): EmergencyRerouteActivatedEventFilter;
    EmergencyRerouteActivated(
      network?: string | null,
      reason?: null
    ): EmergencyRerouteActivatedEventFilter;

    "NetworkMetricsUpdated(address,uint256,uint256)"(
      network?: string | null,
      successRate?: null,
      averageLatency?: null
    ): NetworkMetricsUpdatedEventFilter;
    NetworkMetricsUpdated(
      network?: string | null,
      successRate?: null,
      averageLatency?: null
    ): NetworkMetricsUpdatedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "RateLimitTriggered(address,uint256,uint256)"(
      network?: string | null,
      currentLoad?: null,
      backoffDuration?: null
    ): RateLimitTriggeredEventFilter;
    RateLimitTriggered(
      network?: string | null,
      currentLoad?: null,
      backoffDuration?: null
    ): RateLimitTriggeredEventFilter;

    "RouteCalculated(bytes32,address[],uint256,uint256)"(
      requestId?: BytesLike | null,
      networks?: null,
      totalCost?: null,
      totalLatency?: null
    ): RouteCalculatedEventFilter;
    RouteCalculated(
      requestId?: BytesLike | null,
      networks?: null,
      totalCost?: null,
      totalLatency?: null
    ): RouteCalculatedEventFilter;

    "RouteExecuted(bytes32,bool,uint256,uint256)"(
      requestId?: BytesLike | null,
      success?: null,
      actualCost?: null,
      actualLatency?: null
    ): RouteExecutedEventFilter;
    RouteExecuted(
      requestId?: BytesLike | null,
      success?: null,
      actualCost?: null,
      actualLatency?: null
    ): RouteExecutedEventFilter;

    "RouteRequested(bytes32,address,address,uint256)"(
      requestId?: BytesLike | null,
      sender?: null,
      targetNetwork?: null,
      amount?: null
    ): RouteRequestedEventFilter;
    RouteRequested(
      requestId?: BytesLike | null,
      sender?: null,
      targetNetwork?: null,
      amount?: null
    ): RouteRequestedEventFilter;

    "RouteRerouted(bytes32,address,address,string)"(
      requestId?: BytesLike | null,
      fromNetwork?: null,
      toNetwork?: null,
      reason?: null
    ): RouteReroutedEventFilter;
    RouteRerouted(
      requestId?: BytesLike | null,
      fromNetwork?: null,
      toNetwork?: null,
      reason?: null
    ): RouteReroutedEventFilter;

    "ThrottleModeChanged(uint8,uint8,string)"(
      oldMode?: null,
      newMode?: null,
      reason?: null
    ): ThrottleModeChangedEventFilter;
    ThrottleModeChanged(
      oldMode?: null,
      newMode?: null,
      reason?: null
    ): ThrottleModeChangedEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    activeNetworks(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addSupportedNetwork(
      network: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    calculatedRoutes(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    currentThrottleMode(overrides?: CallOverrides): Promise<BigNumber>;

    economicsOracle(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyPauseNetwork(
      network: string,
      reason: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    executeRoute(
      requestId: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    failedRoutes(overrides?: CallOverrides): Promise<BigNumber>;

    getCalculatedRoute(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNetworkMetrics(
      network: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRouteRequest(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSystemStats(overrides?: CallOverrides): Promise<BigNumber>;

    lastThrottleUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    networkMetrics(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    pendingRequests(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rateLimits(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    requestRoute(
      targetNetwork: string,
      amount: BigNumberish,
      maxCost: BigNumberish,
      maxLatency: BigNumberish,
      priority: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    reroutedTransactions(overrides?: CallOverrides): Promise<BigNumber>;

    routeConfig(overrides?: CallOverrides): Promise<BigNumber>;

    routeRequests(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setThrottleMode(
      mode: BigNumberish,
      reason: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    successfulRoutes(overrides?: CallOverrides): Promise<BigNumber>;

    supportedNetworks(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalRequests(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateRouteConfig(
      newConfig: CrossChainRouteOptimizer.RouteConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    activeNetworks(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addSupportedNetwork(
      network: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    calculatedRoutes(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    currentThrottleMode(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    economicsOracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyPauseNetwork(
      network: string,
      reason: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    executeRoute(
      requestId: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    failedRoutes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCalculatedRoute(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNetworkMetrics(
      network: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRouteRequest(
      requestId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSystemStats(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastThrottleUpdate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    networkMetrics(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingRequests(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rateLimits(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    requestRoute(
      targetNetwork: string,
      amount: BigNumberish,
      maxCost: BigNumberish,
      maxLatency: BigNumberish,
      priority: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    reroutedTransactions(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    routeConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    routeRequests(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setThrottleMode(
      mode: BigNumberish,
      reason: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    successfulRoutes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportedNetworks(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalRequests(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateRouteConfig(
      newConfig: CrossChainRouteOptimizer.RouteConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
