/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../../common";

export declare namespace IStabilityPool {
  export type AMMInterventionStruct = {
    executed: boolean;
    tradeType: BigNumberish;
    amountIn: BigNumberish;
    amountOut: BigNumberish;
    timestamp: BigNumberish;
  };

  export type AMMInterventionStructOutput = [
    boolean,
    number,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    executed: boolean;
    tradeType: number;
    amountIn: BigNumber;
    amountOut: BigNumber;
    timestamp: BigNumber;
  };

  export type ReserveStateStruct = {
    balance: BigNumberish;
    lastUpdate: BigNumberish;
    isActive: boolean;
  };

  export type ReserveStateStructOutput = [BigNumber, BigNumber, boolean] & {
    balance: BigNumber;
    lastUpdate: BigNumber;
    isActive: boolean;
  };

  export type PoolCompositionStruct = {
    totalBalance: BigNumberish;
    penaltyFunds: BigNumberish;
    demurrageFunds: BigNumberish;
    reserveFunds: BigNumberish;
    emergencyFunds: BigNumberish;
  };

  export type PoolCompositionStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    totalBalance: BigNumber;
    penaltyFunds: BigNumber;
    demurrageFunds: BigNumber;
    reserveFunds: BigNumber;
    emergencyFunds: BigNumber;
  };

  export type StabilityMetricsStruct = {
    stabilityIndex: BigNumberish;
    reserveRatio: BigNumberish;
    interventionCount: BigNumberish;
    lastUpdate: BigNumberish;
    emergencyMode: boolean;
  };

  export type StabilityMetricsStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    stabilityIndex: BigNumber;
    reserveRatio: BigNumber;
    interventionCount: BigNumber;
    lastUpdate: BigNumber;
    emergencyMode: boolean;
  };

  export type RebalanceOperationStruct = {
    executed: boolean;
    sourceChain: BigNumberish;
    targetChain: BigNumberish;
    amount: BigNumberish;
    timestamp: BigNumberish;
  };

  export type RebalanceOperationStructOutput = [
    boolean,
    number,
    number,
    BigNumber,
    BigNumber
  ] & {
    executed: boolean;
    sourceChain: number;
    targetChain: number;
    amount: BigNumber;
    timestamp: BigNumber;
  };
}

export interface StabilityPoolInterface extends utils.Interface {
  functions: {
    "BASIS_POINTS()": FunctionFragment;
    "MAX_RESERVE_RATIO()": FunctionFragment;
    "MIN_RESERVE_RATIO()": FunctionFragment;
    "PRECISION()": FunctionFragment;
    "REBALANCE_THRESHOLD()": FunctionFragment;
    "TARGET_RESERVE_RATIO()": FunctionFragment;
    "addEmergencyOperator(address)": FunctionFragment;
    "addSupportedChain(uint32,address)": FunctionFragment;
    "ammRouter()": FunctionFragment;
    "calculateReserveRatio()": FunctionFragment;
    "chainPoolAddresses(uint32)": FunctionFragment;
    "chainReserves(uint32)": FunctionFragment;
    "contributeReserves(uint256)": FunctionFragment;
    "demurrageFunds()": FunctionFragment;
    "emergencyFunds()": FunctionFragment;
    "emergencyMode()": FunctionFragment;
    "emergencyOperators(address)": FunctionFragment;
    "emergencyThreshold()": FunctionFragment;
    "executeAMMIntervention(uint256,uint256)": FunctionFragment;
    "executeEmergencyIntervention(string,uint8)": FunctionFragment;
    "gateToken()": FunctionFragment;
    "getChainReserveState(uint32)": FunctionFragment;
    "getPoolComposition()": FunctionFragment;
    "getStabilityMetrics()": FunctionFragment;
    "interventionCount()": FunctionFragment;
    "lastRebalance()": FunctionFragment;
    "lastStabilityUpdate()": FunctionFragment;
    "maxSlippage()": FunctionFragment;
    "owner()": FunctionFragment;
    "pause()": FunctionFragment;
    "paused()": FunctionFragment;
    "penaltyFunds()": FunctionFragment;
    "rebalanceChainReserves(uint32)": FunctionFragment;
    "rebalanceFrequency()": FunctionFragment;
    "receiveDemurrage(uint256,address)": FunctionFragment;
    "receivePenalty(uint256,address)": FunctionFragment;
    "removeEmergencyOperator(address)": FunctionFragment;
    "removeSupportedChain(uint32)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "reserveFunds()": FunctionFragment;
    "setAMMRouter(address)": FunctionFragment;
    "setEmergencyThreshold(uint256)": FunctionFragment;
    "setRebalanceFrequency(uint256)": FunctionFragment;
    "stabilityIndex()": FunctionFragment;
    "supportedChains(uint32)": FunctionFragment;
    "totalPoolBalance()": FunctionFragment;
    "totalReserves()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unpause()": FunctionFragment;
    "usdcToken()": FunctionFragment;
    "withdrawEmergencyFunds(uint256,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "BASIS_POINTS"
      | "MAX_RESERVE_RATIO"
      | "MIN_RESERVE_RATIO"
      | "PRECISION"
      | "REBALANCE_THRESHOLD"
      | "TARGET_RESERVE_RATIO"
      | "addEmergencyOperator"
      | "addSupportedChain"
      | "ammRouter"
      | "calculateReserveRatio"
      | "chainPoolAddresses"
      | "chainReserves"
      | "contributeReserves"
      | "demurrageFunds"
      | "emergencyFunds"
      | "emergencyMode"
      | "emergencyOperators"
      | "emergencyThreshold"
      | "executeAMMIntervention"
      | "executeEmergencyIntervention"
      | "gateToken"
      | "getChainReserveState"
      | "getPoolComposition"
      | "getStabilityMetrics"
      | "interventionCount"
      | "lastRebalance"
      | "lastStabilityUpdate"
      | "maxSlippage"
      | "owner"
      | "pause"
      | "paused"
      | "penaltyFunds"
      | "rebalanceChainReserves"
      | "rebalanceFrequency"
      | "receiveDemurrage"
      | "receivePenalty"
      | "removeEmergencyOperator"
      | "removeSupportedChain"
      | "renounceOwnership"
      | "reserveFunds"
      | "setAMMRouter"
      | "setEmergencyThreshold"
      | "setRebalanceFrequency"
      | "stabilityIndex"
      | "supportedChains"
      | "totalPoolBalance"
      | "totalReserves"
      | "transferOwnership"
      | "unpause"
      | "usdcToken"
      | "withdrawEmergencyFunds"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "BASIS_POINTS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_RESERVE_RATIO",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_RESERVE_RATIO",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "PRECISION", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "REBALANCE_THRESHOLD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "TARGET_RESERVE_RATIO",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addEmergencyOperator",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "addSupportedChain",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(functionFragment: "ammRouter", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "calculateReserveRatio",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "chainPoolAddresses",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "chainReserves",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "contributeReserves",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "demurrageFunds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyFunds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyMode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyOperators",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyThreshold",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeAMMIntervention",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeEmergencyIntervention",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "gateToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getChainReserveState",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolComposition",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStabilityMetrics",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "interventionCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastRebalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastStabilityUpdate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "maxSlippage",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "penaltyFunds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rebalanceChainReserves",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rebalanceFrequency",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "receiveDemurrage",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "receivePenalty",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeEmergencyOperator",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeSupportedChain",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reserveFunds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setAMMRouter",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setEmergencyThreshold",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setRebalanceFrequency",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "stabilityIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "supportedChains",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "totalPoolBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(functionFragment: "usdcToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdrawEmergencyFunds",
    values: [BigNumberish, string]
  ): string;

  decodeFunctionResult(
    functionFragment: "BASIS_POINTS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_RESERVE_RATIO",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_RESERVE_RATIO",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "PRECISION", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "REBALANCE_THRESHOLD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "TARGET_RESERVE_RATIO",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addEmergencyOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSupportedChain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ammRouter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "calculateReserveRatio",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "chainPoolAddresses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "chainReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contributeReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "demurrageFunds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyFunds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyOperators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeAMMIntervention",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeEmergencyIntervention",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gateToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getChainReserveState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolComposition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStabilityMetrics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "interventionCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastRebalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastStabilityUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxSlippage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "penaltyFunds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rebalanceChainReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rebalanceFrequency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "receiveDemurrage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "receivePenalty",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeEmergencyOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeSupportedChain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reserveFunds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAMMRouter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setEmergencyThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRebalanceFrequency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stabilityIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportedChains",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalPoolBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "usdcToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawEmergencyFunds",
    data: BytesLike
  ): Result;

  events: {
    "AMMTradeExecuted(bool,uint256,uint256)": EventFragment;
    "EmergencyIntervention(string,uint256)": EventFragment;
    "FundsReceived(uint8,uint256,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Paused(address)": EventFragment;
    "ReserveRebalanced(uint32,uint256,bool)": EventFragment;
    "StabilityIndexUpdated(uint256,uint256)": EventFragment;
    "StabilityIntervention(uint8,uint256,uint256)": EventFragment;
    "Unpaused(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AMMTradeExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EmergencyIntervention"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FundsReceived"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReserveRebalanced"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StabilityIndexUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StabilityIntervention"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}

export interface AMMTradeExecutedEventObject {
  isBuy: boolean;
  amountIn: BigNumber;
  amountOut: BigNumber;
}
export type AMMTradeExecutedEvent = TypedEvent<
  [boolean, BigNumber, BigNumber],
  AMMTradeExecutedEventObject
>;

export type AMMTradeExecutedEventFilter =
  TypedEventFilter<AMMTradeExecutedEvent>;

export interface EmergencyInterventionEventObject {
  reason: string;
  amount: BigNumber;
}
export type EmergencyInterventionEvent = TypedEvent<
  [string, BigNumber],
  EmergencyInterventionEventObject
>;

export type EmergencyInterventionEventFilter =
  TypedEventFilter<EmergencyInterventionEvent>;

export interface FundsReceivedEventObject {
  fundType: number;
  amount: BigNumber;
  from: string;
}
export type FundsReceivedEvent = TypedEvent<
  [number, BigNumber, string],
  FundsReceivedEventObject
>;

export type FundsReceivedEventFilter = TypedEventFilter<FundsReceivedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface ReserveRebalancedEventObject {
  chainId: number;
  amount: BigNumber;
  isAddition: boolean;
}
export type ReserveRebalancedEvent = TypedEvent<
  [number, BigNumber, boolean],
  ReserveRebalancedEventObject
>;

export type ReserveRebalancedEventFilter =
  TypedEventFilter<ReserveRebalancedEvent>;

export interface StabilityIndexUpdatedEventObject {
  oldIndex: BigNumber;
  newIndex: BigNumber;
}
export type StabilityIndexUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  StabilityIndexUpdatedEventObject
>;

export type StabilityIndexUpdatedEventFilter =
  TypedEventFilter<StabilityIndexUpdatedEvent>;

export interface StabilityInterventionEventObject {
  intervention: number;
  amount: BigNumber;
  newStability: BigNumber;
}
export type StabilityInterventionEvent = TypedEvent<
  [number, BigNumber, BigNumber],
  StabilityInterventionEventObject
>;

export type StabilityInterventionEventFilter =
  TypedEventFilter<StabilityInterventionEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface StabilityPool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: StabilityPoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BASIS_POINTS(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_RESERVE_RATIO(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_RESERVE_RATIO(overrides?: CallOverrides): Promise<[BigNumber]>;

    PRECISION(overrides?: CallOverrides): Promise<[BigNumber]>;

    REBALANCE_THRESHOLD(overrides?: CallOverrides): Promise<[BigNumber]>;

    TARGET_RESERVE_RATIO(overrides?: CallOverrides): Promise<[BigNumber]>;

    addEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    addSupportedChain(
      chainId: BigNumberish,
      poolAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    ammRouter(overrides?: CallOverrides): Promise<[string]>;

    calculateReserveRatio(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { ratio: BigNumber }>;

    chainPoolAddresses(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    chainReserves(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        balance: BigNumber;
        lastUpdate: BigNumber;
        isActive: boolean;
      }
    >;

    contributeReserves(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    demurrageFunds(overrides?: CallOverrides): Promise<[BigNumber]>;

    emergencyFunds(overrides?: CallOverrides): Promise<[BigNumber]>;

    emergencyMode(overrides?: CallOverrides): Promise<[boolean]>;

    emergencyOperators(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    emergencyThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;

    executeAMMIntervention(
      currentPrice: BigNumberish,
      targetPrice: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    executeEmergencyIntervention(
      reason: string,
      interventionType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    gateToken(overrides?: CallOverrides): Promise<[string]>;

    getChainReserveState(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [IStabilityPool.ReserveStateStructOutput] & {
        state: IStabilityPool.ReserveStateStructOutput;
      }
    >;

    getPoolComposition(
      overrides?: CallOverrides
    ): Promise<
      [IStabilityPool.PoolCompositionStructOutput] & {
        composition: IStabilityPool.PoolCompositionStructOutput;
      }
    >;

    getStabilityMetrics(
      overrides?: CallOverrides
    ): Promise<
      [IStabilityPool.StabilityMetricsStructOutput] & {
        metrics: IStabilityPool.StabilityMetricsStructOutput;
      }
    >;

    interventionCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastRebalance(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastStabilityUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    maxSlippage(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pause(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    penaltyFunds(overrides?: CallOverrides): Promise<[BigNumber]>;

    rebalanceChainReserves(
      targetChain: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    rebalanceFrequency(overrides?: CallOverrides): Promise<[BigNumber]>;

    receiveDemurrage(
      amount: BigNumberish,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    receivePenalty(
      amount: BigNumberish,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    removeEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    removeSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    reserveFunds(overrides?: CallOverrides): Promise<[BigNumber]>;

    setAMMRouter(
      _ammRouter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setEmergencyThreshold(
      threshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setRebalanceFrequency(
      frequency: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    stabilityIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    supportedChains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    totalPoolBalance(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalReserves(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    unpause(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    usdcToken(overrides?: CallOverrides): Promise<[string]>;

    withdrawEmergencyFunds(
      amount: BigNumberish,
      recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  BASIS_POINTS(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

  PRECISION(overrides?: CallOverrides): Promise<BigNumber>;

  REBALANCE_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

  TARGET_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

  addEmergencyOperator(
    operator: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  addSupportedChain(
    chainId: BigNumberish,
    poolAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  ammRouter(overrides?: CallOverrides): Promise<string>;

  calculateReserveRatio(overrides?: CallOverrides): Promise<BigNumber>;

  chainPoolAddresses(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  chainReserves(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, boolean] & {
      balance: BigNumber;
      lastUpdate: BigNumber;
      isActive: boolean;
    }
  >;

  contributeReserves(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  demurrageFunds(overrides?: CallOverrides): Promise<BigNumber>;

  emergencyFunds(overrides?: CallOverrides): Promise<BigNumber>;

  emergencyMode(overrides?: CallOverrides): Promise<boolean>;

  emergencyOperators(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  emergencyThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  executeAMMIntervention(
    currentPrice: BigNumberish,
    targetPrice: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  executeEmergencyIntervention(
    reason: string,
    interventionType: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  gateToken(overrides?: CallOverrides): Promise<string>;

  getChainReserveState(
    chainId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<IStabilityPool.ReserveStateStructOutput>;

  getPoolComposition(
    overrides?: CallOverrides
  ): Promise<IStabilityPool.PoolCompositionStructOutput>;

  getStabilityMetrics(
    overrides?: CallOverrides
  ): Promise<IStabilityPool.StabilityMetricsStructOutput>;

  interventionCount(overrides?: CallOverrides): Promise<BigNumber>;

  lastRebalance(overrides?: CallOverrides): Promise<BigNumber>;

  lastStabilityUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  maxSlippage(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  pause(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  penaltyFunds(overrides?: CallOverrides): Promise<BigNumber>;

  rebalanceChainReserves(
    targetChain: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  rebalanceFrequency(overrides?: CallOverrides): Promise<BigNumber>;

  receiveDemurrage(
    amount: BigNumberish,
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  receivePenalty(
    amount: BigNumberish,
    account: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  removeEmergencyOperator(
    operator: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  removeSupportedChain(
    chainId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  reserveFunds(overrides?: CallOverrides): Promise<BigNumber>;

  setAMMRouter(
    _ammRouter: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setEmergencyThreshold(
    threshold: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setRebalanceFrequency(
    frequency: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  stabilityIndex(overrides?: CallOverrides): Promise<BigNumber>;

  supportedChains(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  totalPoolBalance(overrides?: CallOverrides): Promise<BigNumber>;

  totalReserves(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  unpause(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  usdcToken(overrides?: CallOverrides): Promise<string>;

  withdrawEmergencyFunds(
    amount: BigNumberish,
    recipient: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    BASIS_POINTS(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

    PRECISION(overrides?: CallOverrides): Promise<BigNumber>;

    REBALANCE_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

    TARGET_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

    addEmergencyOperator(
      operator: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addSupportedChain(
      chainId: BigNumberish,
      poolAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    ammRouter(overrides?: CallOverrides): Promise<string>;

    calculateReserveRatio(overrides?: CallOverrides): Promise<BigNumber>;

    chainPoolAddresses(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    chainReserves(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        balance: BigNumber;
        lastUpdate: BigNumber;
        isActive: boolean;
      }
    >;

    contributeReserves(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    demurrageFunds(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyFunds(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyMode(overrides?: CallOverrides): Promise<boolean>;

    emergencyOperators(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    emergencyThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    executeAMMIntervention(
      currentPrice: BigNumberish,
      targetPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<IStabilityPool.AMMInterventionStructOutput>;

    executeEmergencyIntervention(
      reason: string,
      interventionType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    gateToken(overrides?: CallOverrides): Promise<string>;

    getChainReserveState(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<IStabilityPool.ReserveStateStructOutput>;

    getPoolComposition(
      overrides?: CallOverrides
    ): Promise<IStabilityPool.PoolCompositionStructOutput>;

    getStabilityMetrics(
      overrides?: CallOverrides
    ): Promise<IStabilityPool.StabilityMetricsStructOutput>;

    interventionCount(overrides?: CallOverrides): Promise<BigNumber>;

    lastRebalance(overrides?: CallOverrides): Promise<BigNumber>;

    lastStabilityUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    maxSlippage(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    penaltyFunds(overrides?: CallOverrides): Promise<BigNumber>;

    rebalanceChainReserves(
      targetChain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<IStabilityPool.RebalanceOperationStructOutput>;

    rebalanceFrequency(overrides?: CallOverrides): Promise<BigNumber>;

    receiveDemurrage(
      amount: BigNumberish,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    receivePenalty(
      amount: BigNumberish,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeEmergencyOperator(
      operator: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeSupportedChain(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    reserveFunds(overrides?: CallOverrides): Promise<BigNumber>;

    setAMMRouter(_ammRouter: string, overrides?: CallOverrides): Promise<void>;

    setEmergencyThreshold(
      threshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setRebalanceFrequency(
      frequency: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    stabilityIndex(overrides?: CallOverrides): Promise<BigNumber>;

    supportedChains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    totalPoolBalance(overrides?: CallOverrides): Promise<BigNumber>;

    totalReserves(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    unpause(overrides?: CallOverrides): Promise<void>;

    usdcToken(overrides?: CallOverrides): Promise<string>;

    withdrawEmergencyFunds(
      amount: BigNumberish,
      recipient: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AMMTradeExecuted(bool,uint256,uint256)"(
      isBuy?: null,
      amountIn?: null,
      amountOut?: null
    ): AMMTradeExecutedEventFilter;
    AMMTradeExecuted(
      isBuy?: null,
      amountIn?: null,
      amountOut?: null
    ): AMMTradeExecutedEventFilter;

    "EmergencyIntervention(string,uint256)"(
      reason?: null,
      amount?: null
    ): EmergencyInterventionEventFilter;
    EmergencyIntervention(
      reason?: null,
      amount?: null
    ): EmergencyInterventionEventFilter;

    "FundsReceived(uint8,uint256,address)"(
      fundType?: null,
      amount?: null,
      from?: null
    ): FundsReceivedEventFilter;
    FundsReceived(
      fundType?: null,
      amount?: null,
      from?: null
    ): FundsReceivedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "ReserveRebalanced(uint32,uint256,bool)"(
      chainId?: null,
      amount?: null,
      isAddition?: null
    ): ReserveRebalancedEventFilter;
    ReserveRebalanced(
      chainId?: null,
      amount?: null,
      isAddition?: null
    ): ReserveRebalancedEventFilter;

    "StabilityIndexUpdated(uint256,uint256)"(
      oldIndex?: null,
      newIndex?: null
    ): StabilityIndexUpdatedEventFilter;
    StabilityIndexUpdated(
      oldIndex?: null,
      newIndex?: null
    ): StabilityIndexUpdatedEventFilter;

    "StabilityIntervention(uint8,uint256,uint256)"(
      intervention?: null,
      amount?: null,
      newStability?: null
    ): StabilityInterventionEventFilter;
    StabilityIntervention(
      intervention?: null,
      amount?: null,
      newStability?: null
    ): StabilityInterventionEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    BASIS_POINTS(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

    PRECISION(overrides?: CallOverrides): Promise<BigNumber>;

    REBALANCE_THRESHOLD(overrides?: CallOverrides): Promise<BigNumber>;

    TARGET_RESERVE_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

    addEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    addSupportedChain(
      chainId: BigNumberish,
      poolAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    ammRouter(overrides?: CallOverrides): Promise<BigNumber>;

    calculateReserveRatio(overrides?: CallOverrides): Promise<BigNumber>;

    chainPoolAddresses(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    chainReserves(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contributeReserves(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    demurrageFunds(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyFunds(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyMode(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyOperators(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    emergencyThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    executeAMMIntervention(
      currentPrice: BigNumberish,
      targetPrice: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    executeEmergencyIntervention(
      reason: string,
      interventionType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    gateToken(overrides?: CallOverrides): Promise<BigNumber>;

    getChainReserveState(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPoolComposition(overrides?: CallOverrides): Promise<BigNumber>;

    getStabilityMetrics(overrides?: CallOverrides): Promise<BigNumber>;

    interventionCount(overrides?: CallOverrides): Promise<BigNumber>;

    lastRebalance(overrides?: CallOverrides): Promise<BigNumber>;

    lastStabilityUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    maxSlippage(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    penaltyFunds(overrides?: CallOverrides): Promise<BigNumber>;

    rebalanceChainReserves(
      targetChain: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    rebalanceFrequency(overrides?: CallOverrides): Promise<BigNumber>;

    receiveDemurrage(
      amount: BigNumberish,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    receivePenalty(
      amount: BigNumberish,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    removeEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    removeSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    reserveFunds(overrides?: CallOverrides): Promise<BigNumber>;

    setAMMRouter(
      _ammRouter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setEmergencyThreshold(
      threshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setRebalanceFrequency(
      frequency: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    stabilityIndex(overrides?: CallOverrides): Promise<BigNumber>;

    supportedChains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalPoolBalance(overrides?: CallOverrides): Promise<BigNumber>;

    totalReserves(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    usdcToken(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawEmergencyFunds(
      amount: BigNumberish,
      recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    BASIS_POINTS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_RESERVE_RATIO(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MIN_RESERVE_RATIO(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PRECISION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    REBALANCE_THRESHOLD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    TARGET_RESERVE_RATIO(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    addSupportedChain(
      chainId: BigNumberish,
      poolAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    ammRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    calculateReserveRatio(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    chainPoolAddresses(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    chainReserves(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contributeReserves(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    demurrageFunds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyFunds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyOperators(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    emergencyThreshold(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executeAMMIntervention(
      currentPrice: BigNumberish,
      targetPrice: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    executeEmergencyIntervention(
      reason: string,
      interventionType: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    gateToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getChainReserveState(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPoolComposition(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStabilityMetrics(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    interventionCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastRebalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastStabilityUpdate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxSlippage(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    penaltyFunds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebalanceChainReserves(
      targetChain: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    rebalanceFrequency(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    receiveDemurrage(
      amount: BigNumberish,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    receivePenalty(
      amount: BigNumberish,
      account: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    removeEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    removeSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    reserveFunds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAMMRouter(
      _ammRouter: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setEmergencyThreshold(
      threshold: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setRebalanceFrequency(
      frequency: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    stabilityIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportedChains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalPoolBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    unpause(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    usdcToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawEmergencyFunds(
      amount: BigNumberish,
      recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
