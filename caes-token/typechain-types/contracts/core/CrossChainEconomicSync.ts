/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../../common";

export type OriginStruct = {
  srcEid: BigNumberish;
  sender: BytesLike;
  nonce: BigNumberish;
};

export type OriginStructOutput = [number, string, BigNumber] & {
  srcEid: number;
  sender: string;
  nonce: BigNumber;
};

export declare namespace CrossChainEconomicSync {
  export type StabilityMetricsStruct = {
    priceStability: BigNumberish;
    liquidityHealth: BigNumberish;
    participationRate: BigNumberish;
    reserveRatio: BigNumberish;
    overallHealth: BigNumberish;
    timestamp: BigNumberish;
    sourceChain: BigNumberish;
  };

  export type StabilityMetricsStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number
  ] & {
    priceStability: BigNumber;
    liquidityHealth: BigNumber;
    participationRate: BigNumber;
    reserveRatio: BigNumber;
    overallHealth: BigNumber;
    timestamp: BigNumber;
    sourceChain: number;
  };

  export type CrossChainParametersStruct = {
    baseDemurrageRate: BigNumberish;
    maxDemurrageRate: BigNumberish;
    stabilityThreshold: BigNumberish;
    fiatDiscountFactor: BigNumberish;
    antiSpeculationPenaltyRate: BigNumberish;
    circuitBreakerThreshold: BigNumberish;
    rebalanceFrequency: BigNumberish;
    timestamp: BigNumberish;
    parameterHash: BytesLike;
  };

  export type CrossChainParametersStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string
  ] & {
    baseDemurrageRate: BigNumber;
    maxDemurrageRate: BigNumber;
    stabilityThreshold: BigNumber;
    fiatDiscountFactor: BigNumber;
    antiSpeculationPenaltyRate: BigNumber;
    circuitBreakerThreshold: BigNumber;
    rebalanceFrequency: BigNumber;
    timestamp: BigNumber;
    parameterHash: string;
  };

  export type BatchSyncDataStruct = {
    parameters: CrossChainEconomicSync.CrossChainParametersStruct[];
    metrics: CrossChainEconomicSync.StabilityMetricsStruct[];
    batchId: BigNumberish;
    totalBatches: BigNumberish;
    batchIndex: BigNumberish;
  };

  export type BatchSyncDataStructOutput = [
    CrossChainEconomicSync.CrossChainParametersStructOutput[],
    CrossChainEconomicSync.StabilityMetricsStructOutput[],
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    parameters: CrossChainEconomicSync.CrossChainParametersStructOutput[];
    metrics: CrossChainEconomicSync.StabilityMetricsStructOutput[];
    batchId: BigNumber;
    totalBatches: BigNumber;
    batchIndex: BigNumber;
  };

  export type EmergencyBroadcastStruct = {
    emergencyType: BigNumberish;
    severity: BigNumberish;
    duration: BigNumberish;
    reason: string;
    initiator: string;
    timestamp: BigNumberish;
  };

  export type EmergencyBroadcastStructOutput = [
    number,
    BigNumber,
    BigNumber,
    string,
    string,
    BigNumber
  ] & {
    emergencyType: number;
    severity: BigNumber;
    duration: BigNumber;
    reason: string;
    initiator: string;
    timestamp: BigNumber;
  };

  export type ChainStatusStruct = {
    isActive: boolean;
    lastHeartbeat: BigNumberish;
    latency: BigNumberish;
    failureCount: BigNumberish;
    lastMetrics: CrossChainEconomicSync.StabilityMetricsStruct;
    lastParameters: CrossChainEconomicSync.CrossChainParametersStruct;
  };

  export type ChainStatusStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    CrossChainEconomicSync.StabilityMetricsStructOutput,
    CrossChainEconomicSync.CrossChainParametersStructOutput
  ] & {
    isActive: boolean;
    lastHeartbeat: BigNumber;
    latency: BigNumber;
    failureCount: BigNumber;
    lastMetrics: CrossChainEconomicSync.StabilityMetricsStructOutput;
    lastParameters: CrossChainEconomicSync.CrossChainParametersStructOutput;
  };

  export type SyncStateStruct = {
    lastSyncTime: BigNumberish;
    syncNonce: BigNumberish;
    lastParameterHash: BytesLike;
    isPending: boolean;
    retryCount: BigNumberish;
    targetChains: BigNumberish[];
  };

  export type SyncStateStructOutput = [
    BigNumber,
    BigNumber,
    string,
    boolean,
    BigNumber,
    number[]
  ] & {
    lastSyncTime: BigNumber;
    syncNonce: BigNumber;
    lastParameterHash: string;
    isPending: boolean;
    retryCount: BigNumber;
    targetChains: number[];
  };

  export type InterventionCommandStruct = {
    commandType: BigNumberish;
    targetParameter: BigNumberish;
    newValue: BigNumberish;
    executionTime: BigNumberish;
    requiresConsensus: boolean;
    consensusThreshold: BigNumberish;
    additionalData: BytesLike;
  };

  export type InterventionCommandStructOutput = [
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    BigNumber,
    string
  ] & {
    commandType: number;
    targetParameter: BigNumber;
    newValue: BigNumber;
    executionTime: BigNumber;
    requiresConsensus: boolean;
    consensusThreshold: BigNumber;
    additionalData: string;
  };
}

export interface CrossChainEconomicSyncInterface extends utils.Interface {
  functions: {
    "MAX_BATCH_SIZE()": FunctionFragment;
    "MAX_RETRIES()": FunctionFragment;
    "MSG_BATCH_SYNC()": FunctionFragment;
    "MSG_EMERGENCY_BROADCAST()": FunctionFragment;
    "MSG_HEALTH_METRICS()": FunctionFragment;
    "MSG_INTERVENTION_COMMAND()": FunctionFragment;
    "MSG_PARAMETER_SYNC()": FunctionFragment;
    "MSG_STABILITY_UPDATE()": FunctionFragment;
    "PARAMETER_VERSION()": FunctionFragment;
    "SYNC_TIMEOUT()": FunctionFragment;
    "activeEmergency()": FunctionFragment;
    "addEmergencyOperator(address)": FunctionFragment;
    "addSupportedChain(uint32)": FunctionFragment;
    "aggregatedMetrics()": FunctionFragment;
    "allowInitializePath((uint32,bytes32,uint64))": FunctionFragment;
    "averageSyncTime()": FunctionFragment;
    "batchSync(((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bytes32)[],(uint256,uint256,uint256,uint256,uint256,uint256,uint32)[],uint256,uint256,uint256),uint32[])": FunctionFragment;
    "broadcastStabilityMetrics((uint256,uint256,uint256,uint256,uint256,uint256,uint32))": FunctionFragment;
    "chainLatency(uint32)": FunctionFragment;
    "chainStatus(uint32)": FunctionFragment;
    "chainSyncState(uint32)": FunctionFragment;
    "clearEmergency()": FunctionFragment;
    "consensusCount(bytes32)": FunctionFragment;
    "consensusVotes(bytes32,uint32)": FunctionFragment;
    "economicEngine()": FunctionFragment;
    "emergencyOperators(address)": FunctionFragment;
    "endpoint()": FunctionFragment;
    "failedSyncAttempts()": FunctionFragment;
    "getActiveEmergency()": FunctionFragment;
    "getAggregatedMetrics()": FunctionFragment;
    "getChainStatus(uint32)": FunctionFragment;
    "getMasterParameters()": FunctionFragment;
    "getSupportedChains()": FunctionFragment;
    "getSyncMetrics()": FunctionFragment;
    "getSyncState(uint32)": FunctionFragment;
    "isComposeMsgSender((uint32,bytes32,uint64),bytes,address)": FunctionFragment;
    "isEmergencyActive()": FunctionFragment;
    "isSupportedChain(uint32)": FunctionFragment;
    "lastMetricsAggregation()": FunctionFragment;
    "lastParameterUpdate()": FunctionFragment;
    "lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)": FunctionFragment;
    "masterParameters()": FunctionFragment;
    "nextNonce(uint32,bytes32)": FunctionFragment;
    "oAppVersion()": FunctionFragment;
    "owner()": FunctionFragment;
    "pause()": FunctionFragment;
    "paused()": FunctionFragment;
    "peers(uint32)": FunctionFragment;
    "pendingInterventions(bytes32)": FunctionFragment;
    "processedMessages(bytes32)": FunctionFragment;
    "removeEmergencyOperator(address)": FunctionFragment;
    "removeSupportedChain(uint32)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "sendEmergencyBroadcast((uint8,uint256,uint256,string,address,uint256))": FunctionFragment;
    "sendInterventionCommand((uint8,uint256,uint256,uint256,bool,uint256,bytes),uint32[])": FunctionFragment;
    "setDelegate(address)": FunctionFragment;
    "setPeer(uint32,bytes32)": FunctionFragment;
    "supportedChains(uint256)": FunctionFragment;
    "synchronizeParameters((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bytes32),uint32[])": FunctionFragment;
    "totalMessagesReceived()": FunctionFragment;
    "totalMessagesSent()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unpause()": FunctionFragment;
    "updateEconomicEngine(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MAX_BATCH_SIZE"
      | "MAX_RETRIES"
      | "MSG_BATCH_SYNC"
      | "MSG_EMERGENCY_BROADCAST"
      | "MSG_HEALTH_METRICS"
      | "MSG_INTERVENTION_COMMAND"
      | "MSG_PARAMETER_SYNC"
      | "MSG_STABILITY_UPDATE"
      | "PARAMETER_VERSION"
      | "SYNC_TIMEOUT"
      | "activeEmergency"
      | "addEmergencyOperator"
      | "addSupportedChain"
      | "aggregatedMetrics"
      | "allowInitializePath"
      | "averageSyncTime"
      | "batchSync"
      | "broadcastStabilityMetrics"
      | "chainLatency"
      | "chainStatus"
      | "chainSyncState"
      | "clearEmergency"
      | "consensusCount"
      | "consensusVotes"
      | "economicEngine"
      | "emergencyOperators"
      | "endpoint"
      | "failedSyncAttempts"
      | "getActiveEmergency"
      | "getAggregatedMetrics"
      | "getChainStatus"
      | "getMasterParameters"
      | "getSupportedChains"
      | "getSyncMetrics"
      | "getSyncState"
      | "isComposeMsgSender"
      | "isEmergencyActive"
      | "isSupportedChain"
      | "lastMetricsAggregation"
      | "lastParameterUpdate"
      | "lzReceive"
      | "masterParameters"
      | "nextNonce"
      | "oAppVersion"
      | "owner"
      | "pause"
      | "paused"
      | "peers"
      | "pendingInterventions"
      | "processedMessages"
      | "removeEmergencyOperator"
      | "removeSupportedChain"
      | "renounceOwnership"
      | "sendEmergencyBroadcast"
      | "sendInterventionCommand"
      | "setDelegate"
      | "setPeer"
      | "supportedChains"
      | "synchronizeParameters"
      | "totalMessagesReceived"
      | "totalMessagesSent"
      | "transferOwnership"
      | "unpause"
      | "updateEconomicEngine"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "MAX_BATCH_SIZE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_RETRIES",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MSG_BATCH_SYNC",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MSG_EMERGENCY_BROADCAST",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MSG_HEALTH_METRICS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MSG_INTERVENTION_COMMAND",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MSG_PARAMETER_SYNC",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MSG_STABILITY_UPDATE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PARAMETER_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "SYNC_TIMEOUT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "activeEmergency",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addEmergencyOperator",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "addSupportedChain",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "aggregatedMetrics",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allowInitializePath",
    values: [OriginStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "averageSyncTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "batchSync",
    values: [CrossChainEconomicSync.BatchSyncDataStruct, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "broadcastStabilityMetrics",
    values: [CrossChainEconomicSync.StabilityMetricsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "chainLatency",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "chainStatus",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "chainSyncState",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "clearEmergency",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "consensusCount",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "consensusVotes",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "economicEngine",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyOperators",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "endpoint", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "failedSyncAttempts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveEmergency",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAggregatedMetrics",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getChainStatus",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMasterParameters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSupportedChains",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSyncMetrics",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSyncState",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isComposeMsgSender",
    values: [OriginStruct, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isEmergencyActive",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isSupportedChain",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "lastMetricsAggregation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastParameterUpdate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lzReceive",
    values: [OriginStruct, BytesLike, BytesLike, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "masterParameters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextNonce",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "oAppVersion",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(functionFragment: "peers", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "pendingInterventions",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "processedMessages",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "removeEmergencyOperator",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeSupportedChain",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "sendEmergencyBroadcast",
    values: [CrossChainEconomicSync.EmergencyBroadcastStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "sendInterventionCommand",
    values: [CrossChainEconomicSync.InterventionCommandStruct, BigNumberish[]]
  ): string;
  encodeFunctionData(functionFragment: "setDelegate", values: [string]): string;
  encodeFunctionData(
    functionFragment: "setPeer",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportedChains",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "synchronizeParameters",
    values: [CrossChainEconomicSync.CrossChainParametersStruct, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "totalMessagesReceived",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalMessagesSent",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updateEconomicEngine",
    values: [string]
  ): string;

  decodeFunctionResult(
    functionFragment: "MAX_BATCH_SIZE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_RETRIES",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MSG_BATCH_SYNC",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MSG_EMERGENCY_BROADCAST",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MSG_HEALTH_METRICS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MSG_INTERVENTION_COMMAND",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MSG_PARAMETER_SYNC",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MSG_STABILITY_UPDATE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PARAMETER_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "SYNC_TIMEOUT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "activeEmergency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addEmergencyOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addSupportedChain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregatedMetrics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allowInitializePath",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "averageSyncTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "batchSync", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "broadcastStabilityMetrics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "chainLatency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "chainStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "chainSyncState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "clearEmergency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "consensusCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "consensusVotes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "economicEngine",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyOperators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "endpoint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "failedSyncAttempts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveEmergency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAggregatedMetrics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getChainStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMasterParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSupportedChains",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSyncMetrics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSyncState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isComposeMsgSender",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isEmergencyActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isSupportedChain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastMetricsAggregation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastParameterUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lzReceive", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "masterParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nextNonce", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "oAppVersion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "peers", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingInterventions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "processedMessages",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeEmergencyOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeSupportedChain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sendEmergencyBroadcast",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sendInterventionCommand",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDelegate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setPeer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportedChains",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "synchronizeParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalMessagesReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalMessagesSent",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateEconomicEngine",
    data: BytesLike
  ): Result;

  events: {
    "BatchSyncCompleted(uint256,uint32[])": EventFragment;
    "ChainStatusUpdated(uint32,bool,uint256)": EventFragment;
    "ConsensusReached(bytes32,uint256)": EventFragment;
    "CrossChainMessage(uint32,uint32,uint8)": EventFragment;
    "EmergencyBroadcastSent(uint8,uint32[])": EventFragment;
    "InterventionCommandExecuted(bytes32,uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "ParametersSynchronized(uint32[],bytes32)": EventFragment;
    "Paused(address)": EventFragment;
    "PeerSet(uint32,bytes32)": EventFragment;
    "StabilityMetricsReceived(uint32,(uint256,uint256,uint256,uint256,uint256,uint256,uint32))": EventFragment;
    "SyncFailure(uint32,string,uint256)": EventFragment;
    "Unpaused(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "BatchSyncCompleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ChainStatusUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ConsensusReached"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CrossChainMessage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EmergencyBroadcastSent"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "InterventionCommandExecuted"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ParametersSynchronized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PeerSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StabilityMetricsReceived"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SyncFailure"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}

export interface BatchSyncCompletedEventObject {
  batchId: BigNumber;
  chains: number[];
}
export type BatchSyncCompletedEvent = TypedEvent<
  [BigNumber, number[]],
  BatchSyncCompletedEventObject
>;

export type BatchSyncCompletedEventFilter =
  TypedEventFilter<BatchSyncCompletedEvent>;

export interface ChainStatusUpdatedEventObject {
  chainId: number;
  isActive: boolean;
  latency: BigNumber;
}
export type ChainStatusUpdatedEvent = TypedEvent<
  [number, boolean, BigNumber],
  ChainStatusUpdatedEventObject
>;

export type ChainStatusUpdatedEventFilter =
  TypedEventFilter<ChainStatusUpdatedEvent>;

export interface ConsensusReachedEventObject {
  interventionId: string;
  votes: BigNumber;
}
export type ConsensusReachedEvent = TypedEvent<
  [string, BigNumber],
  ConsensusReachedEventObject
>;

export type ConsensusReachedEventFilter =
  TypedEventFilter<ConsensusReachedEvent>;

export interface CrossChainMessageEventObject {
  fromChain: number;
  toChain: number;
  messageType: number;
}
export type CrossChainMessageEvent = TypedEvent<
  [number, number, number],
  CrossChainMessageEventObject
>;

export type CrossChainMessageEventFilter =
  TypedEventFilter<CrossChainMessageEvent>;

export interface EmergencyBroadcastSentEventObject {
  emergencyType: number;
  targetChains: number[];
}
export type EmergencyBroadcastSentEvent = TypedEvent<
  [number, number[]],
  EmergencyBroadcastSentEventObject
>;

export type EmergencyBroadcastSentEventFilter =
  TypedEventFilter<EmergencyBroadcastSentEvent>;

export interface InterventionCommandExecutedEventObject {
  commandId: string;
  commandType: number;
}
export type InterventionCommandExecutedEvent = TypedEvent<
  [string, number],
  InterventionCommandExecutedEventObject
>;

export type InterventionCommandExecutedEventFilter =
  TypedEventFilter<InterventionCommandExecutedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface ParametersSynchronizedEventObject {
  chains: number[];
  parameterHash: string;
}
export type ParametersSynchronizedEvent = TypedEvent<
  [number[], string],
  ParametersSynchronizedEventObject
>;

export type ParametersSynchronizedEventFilter =
  TypedEventFilter<ParametersSynchronizedEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface PeerSetEventObject {
  eid: number;
  peer: string;
}
export type PeerSetEvent = TypedEvent<[number, string], PeerSetEventObject>;

export type PeerSetEventFilter = TypedEventFilter<PeerSetEvent>;

export interface StabilityMetricsReceivedEventObject {
  fromChain: number;
  metrics: CrossChainEconomicSync.StabilityMetricsStructOutput;
}
export type StabilityMetricsReceivedEvent = TypedEvent<
  [number, CrossChainEconomicSync.StabilityMetricsStructOutput],
  StabilityMetricsReceivedEventObject
>;

export type StabilityMetricsReceivedEventFilter =
  TypedEventFilter<StabilityMetricsReceivedEvent>;

export interface SyncFailureEventObject {
  chainId: number;
  reason: string;
  retryCount: BigNumber;
}
export type SyncFailureEvent = TypedEvent<
  [number, string, BigNumber],
  SyncFailureEventObject
>;

export type SyncFailureEventFilter = TypedEventFilter<SyncFailureEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface CrossChainEconomicSync extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CrossChainEconomicSyncInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    MAX_BATCH_SIZE(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_RETRIES(overrides?: CallOverrides): Promise<[BigNumber]>;

    MSG_BATCH_SYNC(overrides?: CallOverrides): Promise<[number]>;

    MSG_EMERGENCY_BROADCAST(overrides?: CallOverrides): Promise<[number]>;

    MSG_HEALTH_METRICS(overrides?: CallOverrides): Promise<[number]>;

    MSG_INTERVENTION_COMMAND(overrides?: CallOverrides): Promise<[number]>;

    MSG_PARAMETER_SYNC(overrides?: CallOverrides): Promise<[number]>;

    MSG_STABILITY_UPDATE(overrides?: CallOverrides): Promise<[number]>;

    PARAMETER_VERSION(overrides?: CallOverrides): Promise<[BigNumber]>;

    SYNC_TIMEOUT(overrides?: CallOverrides): Promise<[BigNumber]>;

    activeEmergency(
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, string, string, BigNumber] & {
        emergencyType: number;
        severity: BigNumber;
        duration: BigNumber;
        reason: string;
        initiator: string;
        timestamp: BigNumber;
      }
    >;

    addEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    addSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    aggregatedMetrics(
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number
      ] & {
        priceStability: BigNumber;
        liquidityHealth: BigNumber;
        participationRate: BigNumber;
        reserveRatio: BigNumber;
        overallHealth: BigNumber;
        timestamp: BigNumber;
        sourceChain: number;
      }
    >;

    allowInitializePath(
      origin: OriginStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    averageSyncTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    batchSync(
      batchData: CrossChainEconomicSync.BatchSyncDataStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    broadcastStabilityMetrics(
      metrics: CrossChainEconomicSync.StabilityMetricsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    chainLatency(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    chainStatus(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        BigNumber,
        BigNumber,
        BigNumber,
        CrossChainEconomicSync.StabilityMetricsStructOutput,
        CrossChainEconomicSync.CrossChainParametersStructOutput
      ] & {
        isActive: boolean;
        lastHeartbeat: BigNumber;
        latency: BigNumber;
        failureCount: BigNumber;
        lastMetrics: CrossChainEconomicSync.StabilityMetricsStructOutput;
        lastParameters: CrossChainEconomicSync.CrossChainParametersStructOutput;
      }
    >;

    chainSyncState(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, boolean, BigNumber] & {
        lastSyncTime: BigNumber;
        syncNonce: BigNumber;
        lastParameterHash: string;
        isPending: boolean;
        retryCount: BigNumber;
      }
    >;

    clearEmergency(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    consensusCount(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    consensusVotes(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    economicEngine(overrides?: CallOverrides): Promise<[string]>;

    emergencyOperators(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    endpoint(overrides?: CallOverrides): Promise<[string]>;

    failedSyncAttempts(overrides?: CallOverrides): Promise<[BigNumber]>;

    getActiveEmergency(
      overrides?: CallOverrides
    ): Promise<[CrossChainEconomicSync.EmergencyBroadcastStructOutput]>;

    getAggregatedMetrics(
      overrides?: CallOverrides
    ): Promise<[CrossChainEconomicSync.StabilityMetricsStructOutput]>;

    getChainStatus(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[CrossChainEconomicSync.ChainStatusStructOutput]>;

    getMasterParameters(
      overrides?: CallOverrides
    ): Promise<[CrossChainEconomicSync.CrossChainParametersStructOutput]>;

    getSupportedChains(overrides?: CallOverrides): Promise<[number[]]>;

    getSyncMetrics(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        messagesSent: BigNumber;
        messagesReceived: BigNumber;
        failedSyncs: BigNumber;
        avgSyncTime: BigNumber;
      }
    >;

    getSyncState(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[CrossChainEconomicSync.SyncStateStructOutput]>;

    isComposeMsgSender(
      arg0: OriginStruct,
      arg1: BytesLike,
      _sender: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isEmergencyActive(overrides?: CallOverrides): Promise<[boolean]>;

    isSupportedChain(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    lastMetricsAggregation(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastParameterUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    lzReceive(
      _origin: OriginStruct,
      _guid: BytesLike,
      _message: BytesLike,
      _executor: string,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    masterParameters(
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string
      ] & {
        baseDemurrageRate: BigNumber;
        maxDemurrageRate: BigNumber;
        stabilityThreshold: BigNumber;
        fiatDiscountFactor: BigNumber;
        antiSpeculationPenaltyRate: BigNumber;
        circuitBreakerThreshold: BigNumber;
        rebalanceFrequency: BigNumber;
        timestamp: BigNumber;
        parameterHash: string;
      }
    >;

    nextNonce(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    oAppVersion(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        senderVersion: BigNumber;
        receiverVersion: BigNumber;
      }
    >;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pause(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    peers(
      eid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { peer: string }>;

    pendingInterventions(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        commandType: number;
        targetParameter: BigNumber;
        newValue: BigNumber;
        executionTime: BigNumber;
        requiresConsensus: boolean;
        consensusThreshold: BigNumber;
        additionalData: string;
      }
    >;

    processedMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    removeEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    removeSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    sendEmergencyBroadcast(
      broadcast: CrossChainEconomicSync.EmergencyBroadcastStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    sendInterventionCommand(
      command: CrossChainEconomicSync.InterventionCommandStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setDelegate(
      _delegate: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setPeer(
      _eid: BigNumberish,
      _peer: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    supportedChains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number]>;

    synchronizeParameters(
      parameters: CrossChainEconomicSync.CrossChainParametersStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    totalMessagesReceived(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalMessagesSent(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    unpause(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateEconomicEngine(
      _economicEngine: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  MAX_BATCH_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_RETRIES(overrides?: CallOverrides): Promise<BigNumber>;

  MSG_BATCH_SYNC(overrides?: CallOverrides): Promise<number>;

  MSG_EMERGENCY_BROADCAST(overrides?: CallOverrides): Promise<number>;

  MSG_HEALTH_METRICS(overrides?: CallOverrides): Promise<number>;

  MSG_INTERVENTION_COMMAND(overrides?: CallOverrides): Promise<number>;

  MSG_PARAMETER_SYNC(overrides?: CallOverrides): Promise<number>;

  MSG_STABILITY_UPDATE(overrides?: CallOverrides): Promise<number>;

  PARAMETER_VERSION(overrides?: CallOverrides): Promise<BigNumber>;

  SYNC_TIMEOUT(overrides?: CallOverrides): Promise<BigNumber>;

  activeEmergency(
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, string, string, BigNumber] & {
      emergencyType: number;
      severity: BigNumber;
      duration: BigNumber;
      reason: string;
      initiator: string;
      timestamp: BigNumber;
    }
  >;

  addEmergencyOperator(
    operator: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  addSupportedChain(
    chainId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  aggregatedMetrics(
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number
    ] & {
      priceStability: BigNumber;
      liquidityHealth: BigNumber;
      participationRate: BigNumber;
      reserveRatio: BigNumber;
      overallHealth: BigNumber;
      timestamp: BigNumber;
      sourceChain: number;
    }
  >;

  allowInitializePath(
    origin: OriginStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  averageSyncTime(overrides?: CallOverrides): Promise<BigNumber>;

  batchSync(
    batchData: CrossChainEconomicSync.BatchSyncDataStruct,
    targetChains: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  broadcastStabilityMetrics(
    metrics: CrossChainEconomicSync.StabilityMetricsStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  chainLatency(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  chainStatus(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      BigNumber,
      BigNumber,
      BigNumber,
      CrossChainEconomicSync.StabilityMetricsStructOutput,
      CrossChainEconomicSync.CrossChainParametersStructOutput
    ] & {
      isActive: boolean;
      lastHeartbeat: BigNumber;
      latency: BigNumber;
      failureCount: BigNumber;
      lastMetrics: CrossChainEconomicSync.StabilityMetricsStructOutput;
      lastParameters: CrossChainEconomicSync.CrossChainParametersStructOutput;
    }
  >;

  chainSyncState(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, string, boolean, BigNumber] & {
      lastSyncTime: BigNumber;
      syncNonce: BigNumber;
      lastParameterHash: string;
      isPending: boolean;
      retryCount: BigNumber;
    }
  >;

  clearEmergency(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  consensusCount(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  consensusVotes(
    arg0: BytesLike,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  economicEngine(overrides?: CallOverrides): Promise<string>;

  emergencyOperators(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  endpoint(overrides?: CallOverrides): Promise<string>;

  failedSyncAttempts(overrides?: CallOverrides): Promise<BigNumber>;

  getActiveEmergency(
    overrides?: CallOverrides
  ): Promise<CrossChainEconomicSync.EmergencyBroadcastStructOutput>;

  getAggregatedMetrics(
    overrides?: CallOverrides
  ): Promise<CrossChainEconomicSync.StabilityMetricsStructOutput>;

  getChainStatus(
    chainId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<CrossChainEconomicSync.ChainStatusStructOutput>;

  getMasterParameters(
    overrides?: CallOverrides
  ): Promise<CrossChainEconomicSync.CrossChainParametersStructOutput>;

  getSupportedChains(overrides?: CallOverrides): Promise<number[]>;

  getSyncMetrics(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      messagesSent: BigNumber;
      messagesReceived: BigNumber;
      failedSyncs: BigNumber;
      avgSyncTime: BigNumber;
    }
  >;

  getSyncState(
    chainId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<CrossChainEconomicSync.SyncStateStructOutput>;

  isComposeMsgSender(
    arg0: OriginStruct,
    arg1: BytesLike,
    _sender: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isEmergencyActive(overrides?: CallOverrides): Promise<boolean>;

  isSupportedChain(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  lastMetricsAggregation(overrides?: CallOverrides): Promise<BigNumber>;

  lastParameterUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  lzReceive(
    _origin: OriginStruct,
    _guid: BytesLike,
    _message: BytesLike,
    _executor: string,
    _extraData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  masterParameters(
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      string
    ] & {
      baseDemurrageRate: BigNumber;
      maxDemurrageRate: BigNumber;
      stabilityThreshold: BigNumber;
      fiatDiscountFactor: BigNumber;
      antiSpeculationPenaltyRate: BigNumber;
      circuitBreakerThreshold: BigNumber;
      rebalanceFrequency: BigNumber;
      timestamp: BigNumber;
      parameterHash: string;
    }
  >;

  nextNonce(
    arg0: BigNumberish,
    arg1: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  oAppVersion(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      senderVersion: BigNumber;
      receiverVersion: BigNumber;
    }
  >;

  owner(overrides?: CallOverrides): Promise<string>;

  pause(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  peers(eid: BigNumberish, overrides?: CallOverrides): Promise<string>;

  pendingInterventions(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
      commandType: number;
      targetParameter: BigNumber;
      newValue: BigNumber;
      executionTime: BigNumber;
      requiresConsensus: boolean;
      consensusThreshold: BigNumber;
      additionalData: string;
    }
  >;

  processedMessages(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  removeEmergencyOperator(
    operator: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  removeSupportedChain(
    chainId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  sendEmergencyBroadcast(
    broadcast: CrossChainEconomicSync.EmergencyBroadcastStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  sendInterventionCommand(
    command: CrossChainEconomicSync.InterventionCommandStruct,
    targetChains: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setDelegate(
    _delegate: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setPeer(
    _eid: BigNumberish,
    _peer: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  supportedChains(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<number>;

  synchronizeParameters(
    parameters: CrossChainEconomicSync.CrossChainParametersStruct,
    targetChains: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  totalMessagesReceived(overrides?: CallOverrides): Promise<BigNumber>;

  totalMessagesSent(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  unpause(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateEconomicEngine(
    _economicEngine: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    MAX_BATCH_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_RETRIES(overrides?: CallOverrides): Promise<BigNumber>;

    MSG_BATCH_SYNC(overrides?: CallOverrides): Promise<number>;

    MSG_EMERGENCY_BROADCAST(overrides?: CallOverrides): Promise<number>;

    MSG_HEALTH_METRICS(overrides?: CallOverrides): Promise<number>;

    MSG_INTERVENTION_COMMAND(overrides?: CallOverrides): Promise<number>;

    MSG_PARAMETER_SYNC(overrides?: CallOverrides): Promise<number>;

    MSG_STABILITY_UPDATE(overrides?: CallOverrides): Promise<number>;

    PARAMETER_VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    SYNC_TIMEOUT(overrides?: CallOverrides): Promise<BigNumber>;

    activeEmergency(
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, string, string, BigNumber] & {
        emergencyType: number;
        severity: BigNumber;
        duration: BigNumber;
        reason: string;
        initiator: string;
        timestamp: BigNumber;
      }
    >;

    addEmergencyOperator(
      operator: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addSupportedChain(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    aggregatedMetrics(
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number
      ] & {
        priceStability: BigNumber;
        liquidityHealth: BigNumber;
        participationRate: BigNumber;
        reserveRatio: BigNumber;
        overallHealth: BigNumber;
        timestamp: BigNumber;
        sourceChain: number;
      }
    >;

    allowInitializePath(
      origin: OriginStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    averageSyncTime(overrides?: CallOverrides): Promise<BigNumber>;

    batchSync(
      batchData: CrossChainEconomicSync.BatchSyncDataStruct,
      targetChains: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    broadcastStabilityMetrics(
      metrics: CrossChainEconomicSync.StabilityMetricsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    chainLatency(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    chainStatus(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        BigNumber,
        BigNumber,
        BigNumber,
        CrossChainEconomicSync.StabilityMetricsStructOutput,
        CrossChainEconomicSync.CrossChainParametersStructOutput
      ] & {
        isActive: boolean;
        lastHeartbeat: BigNumber;
        latency: BigNumber;
        failureCount: BigNumber;
        lastMetrics: CrossChainEconomicSync.StabilityMetricsStructOutput;
        lastParameters: CrossChainEconomicSync.CrossChainParametersStructOutput;
      }
    >;

    chainSyncState(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, boolean, BigNumber] & {
        lastSyncTime: BigNumber;
        syncNonce: BigNumber;
        lastParameterHash: string;
        isPending: boolean;
        retryCount: BigNumber;
      }
    >;

    clearEmergency(overrides?: CallOverrides): Promise<void>;

    consensusCount(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    consensusVotes(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    economicEngine(overrides?: CallOverrides): Promise<string>;

    emergencyOperators(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    endpoint(overrides?: CallOverrides): Promise<string>;

    failedSyncAttempts(overrides?: CallOverrides): Promise<BigNumber>;

    getActiveEmergency(
      overrides?: CallOverrides
    ): Promise<CrossChainEconomicSync.EmergencyBroadcastStructOutput>;

    getAggregatedMetrics(
      overrides?: CallOverrides
    ): Promise<CrossChainEconomicSync.StabilityMetricsStructOutput>;

    getChainStatus(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<CrossChainEconomicSync.ChainStatusStructOutput>;

    getMasterParameters(
      overrides?: CallOverrides
    ): Promise<CrossChainEconomicSync.CrossChainParametersStructOutput>;

    getSupportedChains(overrides?: CallOverrides): Promise<number[]>;

    getSyncMetrics(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        messagesSent: BigNumber;
        messagesReceived: BigNumber;
        failedSyncs: BigNumber;
        avgSyncTime: BigNumber;
      }
    >;

    getSyncState(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<CrossChainEconomicSync.SyncStateStructOutput>;

    isComposeMsgSender(
      arg0: OriginStruct,
      arg1: BytesLike,
      _sender: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isEmergencyActive(overrides?: CallOverrides): Promise<boolean>;

    isSupportedChain(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lastMetricsAggregation(overrides?: CallOverrides): Promise<BigNumber>;

    lastParameterUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lzReceive(
      _origin: OriginStruct,
      _guid: BytesLike,
      _message: BytesLike,
      _executor: string,
      _extraData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    masterParameters(
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string
      ] & {
        baseDemurrageRate: BigNumber;
        maxDemurrageRate: BigNumber;
        stabilityThreshold: BigNumber;
        fiatDiscountFactor: BigNumber;
        antiSpeculationPenaltyRate: BigNumber;
        circuitBreakerThreshold: BigNumber;
        rebalanceFrequency: BigNumber;
        timestamp: BigNumber;
        parameterHash: string;
      }
    >;

    nextNonce(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oAppVersion(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        senderVersion: BigNumber;
        receiverVersion: BigNumber;
      }
    >;

    owner(overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    peers(eid: BigNumberish, overrides?: CallOverrides): Promise<string>;

    pendingInterventions(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        commandType: number;
        targetParameter: BigNumber;
        newValue: BigNumber;
        executionTime: BigNumber;
        requiresConsensus: boolean;
        consensusThreshold: BigNumber;
        additionalData: string;
      }
    >;

    processedMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    removeEmergencyOperator(
      operator: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeSupportedChain(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    sendEmergencyBroadcast(
      broadcast: CrossChainEconomicSync.EmergencyBroadcastStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    sendInterventionCommand(
      command: CrossChainEconomicSync.InterventionCommandStruct,
      targetChains: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    setDelegate(_delegate: string, overrides?: CallOverrides): Promise<void>;

    setPeer(
      _eid: BigNumberish,
      _peer: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    supportedChains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    synchronizeParameters(
      parameters: CrossChainEconomicSync.CrossChainParametersStruct,
      targetChains: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    totalMessagesReceived(overrides?: CallOverrides): Promise<BigNumber>;

    totalMessagesSent(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    unpause(overrides?: CallOverrides): Promise<void>;

    updateEconomicEngine(
      _economicEngine: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "BatchSyncCompleted(uint256,uint32[])"(
      batchId?: null,
      chains?: null
    ): BatchSyncCompletedEventFilter;
    BatchSyncCompleted(
      batchId?: null,
      chains?: null
    ): BatchSyncCompletedEventFilter;

    "ChainStatusUpdated(uint32,bool,uint256)"(
      chainId?: null,
      isActive?: null,
      latency?: null
    ): ChainStatusUpdatedEventFilter;
    ChainStatusUpdated(
      chainId?: null,
      isActive?: null,
      latency?: null
    ): ChainStatusUpdatedEventFilter;

    "ConsensusReached(bytes32,uint256)"(
      interventionId?: null,
      votes?: null
    ): ConsensusReachedEventFilter;
    ConsensusReached(
      interventionId?: null,
      votes?: null
    ): ConsensusReachedEventFilter;

    "CrossChainMessage(uint32,uint32,uint8)"(
      fromChain?: null,
      toChain?: null,
      messageType?: null
    ): CrossChainMessageEventFilter;
    CrossChainMessage(
      fromChain?: null,
      toChain?: null,
      messageType?: null
    ): CrossChainMessageEventFilter;

    "EmergencyBroadcastSent(uint8,uint32[])"(
      emergencyType?: null,
      targetChains?: null
    ): EmergencyBroadcastSentEventFilter;
    EmergencyBroadcastSent(
      emergencyType?: null,
      targetChains?: null
    ): EmergencyBroadcastSentEventFilter;

    "InterventionCommandExecuted(bytes32,uint8)"(
      commandId?: null,
      commandType?: null
    ): InterventionCommandExecutedEventFilter;
    InterventionCommandExecuted(
      commandId?: null,
      commandType?: null
    ): InterventionCommandExecutedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "ParametersSynchronized(uint32[],bytes32)"(
      chains?: null,
      parameterHash?: null
    ): ParametersSynchronizedEventFilter;
    ParametersSynchronized(
      chains?: null,
      parameterHash?: null
    ): ParametersSynchronizedEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "PeerSet(uint32,bytes32)"(eid?: null, peer?: null): PeerSetEventFilter;
    PeerSet(eid?: null, peer?: null): PeerSetEventFilter;

    "StabilityMetricsReceived(uint32,(uint256,uint256,uint256,uint256,uint256,uint256,uint32))"(
      fromChain?: null,
      metrics?: null
    ): StabilityMetricsReceivedEventFilter;
    StabilityMetricsReceived(
      fromChain?: null,
      metrics?: null
    ): StabilityMetricsReceivedEventFilter;

    "SyncFailure(uint32,string,uint256)"(
      chainId?: null,
      reason?: null,
      retryCount?: null
    ): SyncFailureEventFilter;
    SyncFailure(
      chainId?: null,
      reason?: null,
      retryCount?: null
    ): SyncFailureEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    MAX_BATCH_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_RETRIES(overrides?: CallOverrides): Promise<BigNumber>;

    MSG_BATCH_SYNC(overrides?: CallOverrides): Promise<BigNumber>;

    MSG_EMERGENCY_BROADCAST(overrides?: CallOverrides): Promise<BigNumber>;

    MSG_HEALTH_METRICS(overrides?: CallOverrides): Promise<BigNumber>;

    MSG_INTERVENTION_COMMAND(overrides?: CallOverrides): Promise<BigNumber>;

    MSG_PARAMETER_SYNC(overrides?: CallOverrides): Promise<BigNumber>;

    MSG_STABILITY_UPDATE(overrides?: CallOverrides): Promise<BigNumber>;

    PARAMETER_VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    SYNC_TIMEOUT(overrides?: CallOverrides): Promise<BigNumber>;

    activeEmergency(overrides?: CallOverrides): Promise<BigNumber>;

    addEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    addSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    aggregatedMetrics(overrides?: CallOverrides): Promise<BigNumber>;

    allowInitializePath(
      origin: OriginStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    averageSyncTime(overrides?: CallOverrides): Promise<BigNumber>;

    batchSync(
      batchData: CrossChainEconomicSync.BatchSyncDataStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    broadcastStabilityMetrics(
      metrics: CrossChainEconomicSync.StabilityMetricsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    chainLatency(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    chainStatus(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    chainSyncState(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    clearEmergency(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    consensusCount(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    consensusVotes(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    economicEngine(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyOperators(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    endpoint(overrides?: CallOverrides): Promise<BigNumber>;

    failedSyncAttempts(overrides?: CallOverrides): Promise<BigNumber>;

    getActiveEmergency(overrides?: CallOverrides): Promise<BigNumber>;

    getAggregatedMetrics(overrides?: CallOverrides): Promise<BigNumber>;

    getChainStatus(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMasterParameters(overrides?: CallOverrides): Promise<BigNumber>;

    getSupportedChains(overrides?: CallOverrides): Promise<BigNumber>;

    getSyncMetrics(overrides?: CallOverrides): Promise<BigNumber>;

    getSyncState(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isComposeMsgSender(
      arg0: OriginStruct,
      arg1: BytesLike,
      _sender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isEmergencyActive(overrides?: CallOverrides): Promise<BigNumber>;

    isSupportedChain(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastMetricsAggregation(overrides?: CallOverrides): Promise<BigNumber>;

    lastParameterUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lzReceive(
      _origin: OriginStruct,
      _guid: BytesLike,
      _message: BytesLike,
      _executor: string,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    masterParameters(overrides?: CallOverrides): Promise<BigNumber>;

    nextNonce(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oAppVersion(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    peers(eid: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    pendingInterventions(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    processedMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    removeSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    sendEmergencyBroadcast(
      broadcast: CrossChainEconomicSync.EmergencyBroadcastStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    sendInterventionCommand(
      command: CrossChainEconomicSync.InterventionCommandStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setDelegate(
      _delegate: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setPeer(
      _eid: BigNumberish,
      _peer: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    supportedChains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    synchronizeParameters(
      parameters: CrossChainEconomicSync.CrossChainParametersStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    totalMessagesReceived(overrides?: CallOverrides): Promise<BigNumber>;

    totalMessagesSent(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    updateEconomicEngine(
      _economicEngine: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    MAX_BATCH_SIZE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_RETRIES(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MSG_BATCH_SYNC(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MSG_EMERGENCY_BROADCAST(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MSG_HEALTH_METRICS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MSG_INTERVENTION_COMMAND(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MSG_PARAMETER_SYNC(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MSG_STABILITY_UPDATE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    PARAMETER_VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SYNC_TIMEOUT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    activeEmergency(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    addSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    aggregatedMetrics(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allowInitializePath(
      origin: OriginStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    averageSyncTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    batchSync(
      batchData: CrossChainEconomicSync.BatchSyncDataStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    broadcastStabilityMetrics(
      metrics: CrossChainEconomicSync.StabilityMetricsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    chainLatency(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    chainStatus(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    chainSyncState(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    clearEmergency(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    consensusCount(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    consensusVotes(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    economicEngine(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyOperators(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    endpoint(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    failedSyncAttempts(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getActiveEmergency(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAggregatedMetrics(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getChainStatus(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMasterParameters(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSupportedChains(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSyncMetrics(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getSyncState(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isComposeMsgSender(
      arg0: OriginStruct,
      arg1: BytesLike,
      _sender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isEmergencyActive(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isSupportedChain(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastMetricsAggregation(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastParameterUpdate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lzReceive(
      _origin: OriginStruct,
      _guid: BytesLike,
      _message: BytesLike,
      _executor: string,
      _extraData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    masterParameters(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextNonce(
      arg0: BigNumberish,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oAppVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    peers(
      eid: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pendingInterventions(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    processedMessages(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeEmergencyOperator(
      operator: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    removeSupportedChain(
      chainId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    sendEmergencyBroadcast(
      broadcast: CrossChainEconomicSync.EmergencyBroadcastStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    sendInterventionCommand(
      command: CrossChainEconomicSync.InterventionCommandStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setDelegate(
      _delegate: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setPeer(
      _eid: BigNumberish,
      _peer: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    supportedChains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    synchronizeParameters(
      parameters: CrossChainEconomicSync.CrossChainParametersStruct,
      targetChains: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    totalMessagesReceived(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalMessagesSent(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    unpause(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateEconomicEngine(
      _economicEngine: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
